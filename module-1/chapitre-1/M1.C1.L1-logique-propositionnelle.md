# üìö Module 1 - Chapitre 1 - Le√ßon 1
# Introduction √† la logique propositionnelle

---

## üìã M√©tadonn√©es de la le√ßon

**Identifiant** : M1.C1.L1  
**Titre** : Introduction √† la logique propositionnelle  
**Pr√©requis** : Aucun (premi√®re le√ßon du curriculum)  
**Temps d'√©tude estim√©** : 4 heures

---

## üéØ Objectifs d'apprentissage

√Ä la fin de cette le√ßon, vous serez capable de :

1. **D√©finir formellement** ce qu'est une proposition logique et distinguer les propositions valides des √©nonc√©s non propositionnels.

2. **Identifier et utiliser** les cinq connecteurs logiques fondamentaux (n√©gation, conjonction, disjonction, implication, √©quivalence) avec leur notation symbolique correcte.

3. **Construire et interpr√©ter** des tables de v√©rit√© pour des formules propositionnelles simples et compos√©es, en d√©terminant syst√©matiquement toutes les combinaisons possibles de valeurs de v√©rit√©.

4. **Appliquer les lois fondamentales de la logique** (commutativit√©, associativit√©, distributivit√©, lois de De Morgan) pour simplifier des expressions logiques et d√©montrer leur √©quivalence.

5. **Traduire des √©nonc√©s en langage naturel** en formules propositionnelles formelles et inversement, en identifiant correctement la structure logique sous-jacente.

6. **Reconna√Ætre et impl√©menter** les √©quivalences entre les op√©rateurs logiques en JavaScript et les connecteurs propositionnels pour √©crire des conditions bool√©ennes correctes et optimis√©es.

---

## üìñ Contenu exhaustif de la le√ßon

### üîç 1. Qu'est-ce qu'une proposition ?

#### D√©finition formelle

Une **proposition** (ou **√©nonc√© d√©claratif**) est une phrase qui peut √™tre soit vraie, soit fausse, mais pas les deux √† la fois. On dit qu'une proposition poss√®de une **valeur de v√©rit√©** qui est soit **vrai** (not√©e V, T, 1 ou ‚ä§) soit **faux** (not√©e F, F, 0 ou ‚ä•).

**Exemples de propositions valides** :
- "PostgreSQL est un syst√®me de gestion de bases de donn√©es relationnelles." (vrai)
- "2 + 2 = 5" (faux)
- "Node.js est bas√© sur le moteur V8 de Chrome." (vrai)
- "Tous les nombres premiers sont impairs." (faux, car 2 est premier et pair)

**Exemples d'√©nonc√©s qui ne sont PAS des propositions** :
- "Quelle heure est-il ?" (question, pas de valeur de v√©rit√©)
- "Fermez la porte." (imp√©ratif, pas de valeur de v√©rit√©)
- "Ce serveur est rapide." (subjectif, pas de valeur de v√©rit√© d√©finie)
- "x > 5" (d√©pend de la valeur de x, c'est une fonction propositionnelle, pas une proposition)

#### Variables propositionnelles

En logique formelle, nous utilisons des **variables propositionnelles** (g√©n√©ralement not√©es p, q, r, s, etc.) pour repr√©senter des propositions. Ces variables peuvent prendre la valeur vrai (V) ou faux (F).

Par exemple :
- Soit p : "Il pleut."
- Soit q : "Je prends un parapluie."

Ces variables nous permettent de raisonner de mani√®re abstraite sans nous concentrer sur le contenu sp√©cifique des propositions.

---

### üîó 2. Les connecteurs logiques fondamentaux

Les connecteurs logiques (ou op√©rateurs logiques) nous permettent de construire des propositions compos√©es √† partir de propositions simples. Il existe cinq connecteurs fondamentaux.

#### 2.1 N√©gation (NOT) - ¬¨

**D√©finition formelle** : La n√©gation d'une proposition p, not√©e ¬¨p (lire "non p"), est vraie si et seulement si p est fausse.

**Notation** : ¬¨p, ~p, ou NOT p

**Table de v√©rit√©** :

| p | ¬¨p |
|---|-----|
| V | F   |
| F | V   |

**Exemple** : Si p est "Il pleut", alors ¬¨p est "Il ne pleut pas".

**En JavaScript** :
```javascript
const p = true;
const notP = !p;  // false
```

#### 2.2 Conjonction (AND) - ‚àß

**D√©finition formelle** : La conjonction de deux propositions p et q, not√©e p ‚àß q (lire "p et q"), est vraie si et seulement si p et q sont toutes les deux vraies.

**Notation** : p ‚àß q, p AND q, p & q

**Table de v√©rit√©** :

| p | q | p ‚àß q |
|---|---|-------|
| V | V | V     |
| V | F | F     |
| F | V | F     |
| F | F | F     |

**Exemple** : Si p est "Le serveur est en ligne" et q est "La base de donn√©es est accessible", alors p ‚àß q est "Le serveur est en ligne ET la base de donn√©es est accessible".

**En JavaScript** :
```javascript
const serverOnline = true;
const databaseAccessible = false;
const systemReady = serverOnline && databaseAccessible;  // false
```

#### 2.3 Disjonction (OR) - ‚à®

**D√©finition formelle** : La disjonction de deux propositions p et q, not√©e p ‚à® q (lire "p ou q"), est vraie si et seulement si au moins une des deux propositions p ou q est vraie.

**Notation** : p ‚à® q, p OR q, p | q

**Table de v√©rit√©** :

| p | q | p ‚à® q |
|---|---|-------|
| V | V | V     |
| V | F | V     |
| F | V | V     |
| F | F | F     |

**Remarque importante** : En logique, le "ou" est **inclusif** (on dit aussi "ou non-exclusif"). Cela signifie que p ‚à® q est vrai m√™me si les deux propositions sont vraies simultan√©ment. Dans le langage courant, le "ou" peut √™tre exclusif ("Tu veux du th√© ou du caf√© ?" sugg√®re un choix exclusif), mais en logique formelle, sauf mention contraire, le "ou" est toujours inclusif.

**Exemple** : Si p est "L'utilisateur a un r√¥le admin" et q est "L'utilisateur a un r√¥le mod√©rateur", alors p ‚à® q est "L'utilisateur a un r√¥le admin OU un r√¥le mod√©rateur (ou les deux)".

**En JavaScript** :
```javascript
const isAdmin = false;
const isModerator = true;
const hasPrivileges = isAdmin || isModerator;  // true
```

#### 2.4 Implication (IF...THEN) - ‚Üí

**D√©finition formelle** : L'implication de p vers q, not√©e p ‚Üí q (lire "p implique q" ou "si p alors q"), est fausse si et seulement si p est vraie et q est fausse. Dans tous les autres cas, elle est vraie.

**Notation** : p ‚Üí q, p ‚áí q, p IMP q

**Table de v√©rit√©** :

| p | q | p ‚Üí q |
|---|---|-------|
| V | V | V     |
| V | F | F     |
| F | V | V     |
| F | F | V     |

**Explication importante** : La ligne la plus contre-intuitive est lorsque p est fausse et q est fausse (ou vraie), l'implication reste vraie. Cela s'appelle le principe de **vacuit√©** : une implication avec une pr√©misse fausse est toujours vraie, car elle ne promet rien dans ce cas.

**Exemple** : Soit p : "Vous √™tes authentifi√©" et q : "Vous pouvez acc√©der au dashboard". L'implication p ‚Üí q signifie "Si vous √™tes authentifi√©, alors vous pouvez acc√©der au dashboard".

- Si vous √™tes authentifi√© (p = V) et pouvez acc√©der (q = V), l'implication est respect√©e (V).
- Si vous √™tes authentifi√© (p = V) mais ne pouvez pas acc√©der (q = F), l'implication est viol√©e (F).
- Si vous n'√™tes pas authentifi√© (p = F), l'implication ne dit rien sur votre acc√®s, donc elle est trivialement vraie quelle que soit la valeur de q.

**En JavaScript** : L'implication n'a pas d'op√©rateur direct, mais peut √™tre exprim√©e ainsi :
```javascript
// p ‚Üí q est √©quivalent √† ¬¨p ‚à® q
const p = false;
const q = true;
const implication = !p || q;  // true
```

#### 2.5 √âquivalence (IF AND ONLY IF) - ‚Üî

**D√©finition formelle** : L'√©quivalence entre p et q, not√©e p ‚Üî q (lire "p si et seulement si q" ou "p est √©quivalent √† q"), est vraie si et seulement si p et q ont la m√™me valeur de v√©rit√©.

**Notation** : p ‚Üî q, p ‚áî q, p IFF q

**Table de v√©rit√©** :

| p | q | p ‚Üî q |
|---|---|-------|
| V | V | V     |
| V | F | F     |
| F | V | F     |
| F | F | V     |

**Remarque** : p ‚Üî q est √©quivalent √† (p ‚Üí q) ‚àß (q ‚Üí p). On dit que p et q s'impliquent mutuellement.

**Exemple** : Soit p : "Le nombre est pair" et q : "Le nombre est divisible par 2". Alors p ‚Üî q signifie "Un nombre est pair si et seulement si il est divisible par 2".

**En JavaScript** :
```javascript
const p = true;
const q = true;
const equivalence = p === q;  // true (en JavaScript, === v√©rifie l'√©quivalence stricte)
```

---

### üìä 3. Tables de v√©rit√© et formules compos√©es

#### Construction de tables de v√©rit√©

Une table de v√©rit√© est un outil fondamental qui √©num√®re toutes les combinaisons possibles de valeurs de v√©rit√© pour les variables propositionnelles d'une formule et calcule la valeur de v√©rit√© r√©sultante pour chaque combinaison.

**M√©thode de construction** :

1. Identifier toutes les variables propositionnelles dans la formule.
2. D√©terminer le nombre de lignes n√©cessaires : si vous avez n variables, vous aurez 2‚Åø lignes (car chaque variable peut √™tre V ou F).
3. Cr√©er une colonne pour chaque variable et pour chaque sous-formule interm√©diaire.
4. Remplir syst√©matiquement toutes les combinaisons possibles de valeurs de v√©rit√©.
5. Calculer les valeurs pour les colonnes interm√©diaires et finalement pour la formule compl√®te.

**Exemple 1** : Construisons la table de v√©rit√© pour la formule (p ‚àß q) ‚à® ¬¨r

Nous avons 3 variables (p, q, r), donc 2¬≥ = 8 lignes.

| p | q | r | p ‚àß q | ¬¨r | (p ‚àß q) ‚à® ¬¨r |
|---|---|---|-------|-----|--------------|
| V | V | V | V     | F   | V            |
| V | V | F | V     | V   | V            |
| V | F | V | F     | F   | F            |
| V | F | F | F     | V   | V            |
| F | V | V | F     | F   | F            |
| F | V | F | F     | V   | V            |
| F | F | V | F     | F   | F            |
| F | F | F | F     | V   | V            |

#### Classification des formules propositionnelles

Une fois qu'on a construit la table de v√©rit√© d'une formule, on peut la classifier :

**Tautologie** : Une formule qui est toujours vraie, quelle que soit la valeur de v√©rit√© de ses variables. Par exemple, p ‚à® ¬¨p est une tautologie.

**Contradiction** : Une formule qui est toujours fausse. Par exemple, p ‚àß ¬¨p est une contradiction.

**Contingence** : Une formule qui est vraie dans certains cas et fausse dans d'autres. C'est le cas de la plupart des formules.

---

### ‚öñÔ∏è 4. Lois fondamentales de la logique propositionnelle

Ces lois permettent de transformer et simplifier des expressions logiques. Elles sont essentielles pour l'optimisation de conditions bool√©ennes en programmation.

#### 4.1 Lois d'identit√©
- p ‚àß V ‚â° p
- p ‚à® F ‚â° p

#### 4.2 Lois de domination
- p ‚à® V ‚â° V
- p ‚àß F ‚â° F

#### 4.3 Lois d'idempotence
- p ‚à® p ‚â° p
- p ‚àß p ‚â° p

#### 4.4 Loi de double n√©gation
- ¬¨(¬¨p) ‚â° p

#### 4.5 Lois de commutativit√©
- p ‚à® q ‚â° q ‚à® p
- p ‚àß q ‚â° q ‚àß p

#### 4.6 Lois d'associativit√©
- (p ‚à® q) ‚à® r ‚â° p ‚à® (q ‚à® r)
- (p ‚àß q) ‚àß r ‚â° p ‚àß (q ‚àß r)

#### 4.7 Lois de distributivit√©
- p ‚à® (q ‚àß r) ‚â° (p ‚à® q) ‚àß (p ‚à® r)
- p ‚àß (q ‚à® r) ‚â° (p ‚àß q) ‚à® (p ‚àß r)

#### 4.8 Lois de De Morgan

Ces lois sont particuli√®rement importantes en programmation :

- ¬¨(p ‚àß q) ‚â° ¬¨p ‚à® ¬¨q
- ¬¨(p ‚à® q) ‚â° ¬¨p ‚àß ¬¨q

**En mots** : "La n√©gation d'une conjonction est la disjonction des n√©gations" et "La n√©gation d'une disjonction est la conjonction des n√©gations".

**Exemple en JavaScript** :
```javascript
// ¬¨(p ‚àß q) ‚â° ¬¨p ‚à® ¬¨q
const p = true;
const q = false;

// Forme originale
const form1 = !(p && q);  // true

// Forme √©quivalente selon De Morgan
const form2 = !p || !q;   // true

console.log(form1 === form2);  // true
```

#### 4.9 Lois d'absorption
- p ‚à® (p ‚àß q) ‚â° p
- p ‚àß (p ‚à® q) ‚â° p

#### 4.10 Lois du tiers exclu et de non-contradiction
- p ‚à® ¬¨p ‚â° V (tiers exclu : une proposition est soit vraie, soit fausse)
- p ‚àß ¬¨p ‚â° F (non-contradiction : une proposition ne peut pas √™tre vraie et fausse en m√™me temps)

---

### üîÑ 5. √âquivalences importantes avec les connecteurs

Il est essentiel de conna√Ætre certaines √©quivalences qui permettent d'exprimer certains connecteurs en termes d'autres :

**Implication en termes de disjonction et n√©gation** :
- p ‚Üí q ‚â° ¬¨p ‚à® q

**√âquivalence en termes d'implication** :
- p ‚Üî q ‚â° (p ‚Üí q) ‚àß (q ‚Üí p)

**√âquivalence en termes de conjonction et disjonction** :
- p ‚Üî q ‚â° (p ‚àß q) ‚à® (¬¨p ‚àß ¬¨q)

Ces √©quivalences sont fondamentales car elles montrent qu'on peut se limiter √† un ensemble minimal de connecteurs (par exemple, ¬¨ et ‚à®, ou ¬¨ et ‚àß) et exprimer tous les autres en termes de ceux-ci.

---

### üåê 6. Application √† la programmation et au d√©veloppement web

#### 6.1 Conditions bool√©ennes en JavaScript

En JavaScript (et dans la plupart des langages de programmation), les op√©rateurs logiques correspondent directement aux connecteurs propositionnels :

| Connecteur logique | Symbole math√©matique | Op√©rateur JavaScript |
|-------------------|---------------------|---------------------|
| N√©gation          | ¬¨p                  | !p                  |
| Conjonction       | p ‚àß q               | p && q              |
| Disjonction       | p ‚à® q               | p \|\| q            |
| Implication       | p ‚Üí q               | !p \|\| q           |
| √âquivalence       | p ‚Üî q               | p === q             |

#### 6.2 Validation de formulaires

Imaginons un formulaire d'inscription avec les r√®gles suivantes :
- L'utilisateur doit avoir au moins 18 ans OU avoir le consentement parental
- L'utilisateur doit accepter les conditions d'utilisation
- Si l'utilisateur veut recevoir la newsletter, il doit fournir un email valide

```javascript
const age = 16;
const hasParentalConsent = true;
const acceptedTerms = true;
const wantsNewsletter = true;
const emailValid = false;

// Traduction en logique propositionnelle :
// p : age >= 18
// q : hasParentalConsent
// r : acceptedTerms
// s : wantsNewsletter
// t : emailValid
// Formule : ((p ‚à® q) ‚àß r) ‚àß (s ‚Üí t)

const ageOk = age >= 18 || hasParentalConsent;
const termsOk = acceptedTerms;
const newsletterOk = !wantsNewsletter || emailValid;  // s ‚Üí t ‚â° ¬¨s ‚à® t

const canRegister = ageOk && termsOk && newsletterOk;

console.log(canRegister);  // false (car newsletterOk est faux)
```

#### 6.3 Requ√™tes SQL avec WHERE

Les clauses WHERE dans PostgreSQL utilisent √©galement la logique propositionnelle :

```sql
-- Trouver les utilisateurs actifs qui sont soit admin, soit ont plus de 100 publications
SELECT * FROM users
WHERE is_active = true 
  AND (role = 'admin' OR post_count > 100);
```

Cette requ√™te traduit la formule logique : p ‚àß (q ‚à® r)
- p : is_active = true
- q : role = 'admin'
- r : post_count > 100

#### 6.4 Optimisation des conditions

Gr√¢ce aux lois logiques, on peut optimiser les conditions. Par exemple :

```javascript
// Condition non optimis√©e
if ((userType === 'premium' || userType === 'admin') && 
    (userType === 'premium' || hasFreeTrialActive)) {
    grantAccess();
}

// Forme : (p ‚à® q) ‚àß (p ‚à® r)
// Par distributivit√© : p ‚à® (q ‚àß r)

// Condition optimis√©e
if (userType === 'premium' || 
    (userType === 'admin' && hasFreeTrialActive)) {
    grantAccess();
}
```

La deuxi√®me forme est plus efficace car elle √©vite d'√©valuer certaines conditions inutilement.

---

### üéì 7. Notation et conventions

Dans ce cours, nous utiliserons les conventions suivantes :

**Priorit√© des op√©rateurs** (de la plus haute √† la plus basse) :
1. ¬¨ (n√©gation)
2. ‚àß (conjonction)
3. ‚à® (disjonction)
4. ‚Üí (implication)
5. ‚Üî (√©quivalence)

Ainsi, p ‚à® q ‚àß r se lit (p ‚à® (q ‚àß r)) et non ((p ‚à® q) ‚àß r). En cas de doute, utilisez des parenth√®ses pour clarifier.

**Notation des valeurs de v√©rit√©** : Nous utiliserons V et F dans les tables de v√©rit√©, mais vous rencontrerez aussi les notations T/F (True/False) ou 1/0 selon les contextes.

---

## üí° Exemple travaill√© d√©taill√©

### Sc√©nario : Syst√®me de contr√¥le d'acc√®s pour une API Express

Vous d√©veloppez une API Express avec Node.js et vous devez impl√©menter un middleware de contr√¥le d'acc√®s. Les r√®gles m√©tier sont les suivantes :

**R√®gles d'acc√®s √† la ressource `/api/admin/users`** :
1. L'utilisateur doit √™tre authentifi√© (avoir un token JWT valide)
2. L'utilisateur doit avoir le r√¥le "admin" OU (avoir le r√¥le "moderator" ET avoir la permission "manage_users")
3. Si la requ√™te modifie des donn√©es (POST, PUT, DELETE), le compte de l'utilisateur ne doit PAS √™tre en lecture seule

Traduisons ces r√®gles en logique propositionnelle, puis impl√©mentons-les en JavaScript.

#### √âtape 1 : Identification des propositions atomiques

Identifions d'abord toutes les propositions simples :

- **p** : "L'utilisateur est authentifi√©"
- **q** : "L'utilisateur a le r√¥le admin"
- **r** : "L'utilisateur a le r√¥le moderator"
- **s** : "L'utilisateur a la permission manage_users"
- **t** : "La requ√™te modifie des donn√©es"
- **u** : "Le compte est en lecture seule"

#### √âtape 2 : Traduction des r√®gles en formules logiques

**R√®gle 1** : p (directement exprim√©e)

**R√®gle 2** : q ‚à® (r ‚àß s)

**R√®gle 3** : t ‚Üí ¬¨u (si la requ√™te modifie, alors le compte n'est pas en lecture seule)

**Formule finale** : L'acc√®s est autoris√© si et seulement si :
**p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u)**

#### √âtape 3 : Construction de la table de v√©rit√©

Avec 6 variables, nous aurions 2‚Å∂ = 64 lignes. Pour l'exemple, analysons quelques cas significatifs :

**Cas 1** : Utilisateur admin authentifi√©, requ√™te GET
- p = V, q = V, r = F, s = F, t = F, u = F
- p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u)
- V ‚àß (V ‚à® F) ‚àß (F ‚Üí V)
- V ‚àß V ‚àß V = **V** ‚úì Acc√®s autoris√©

**Cas 2** : Utilisateur moderator avec permission, authentifi√©, requ√™te POST, compte lecture seule
- p = V, q = F, r = V, s = V, t = V, u = V
- p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u)
- V ‚àß (F ‚à® V) ‚àß (V ‚Üí F)
- V ‚àß V ‚àß F = **F** ‚úó Acc√®s refus√© (√† cause de la lecture seule)

**Cas 3** : Utilisateur moderator SANS permission, authentifi√©
- p = V, q = F, r = V, s = F, t = F, u = F
- p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u)
- V ‚àß (F ‚à® F) ‚àß V
- V ‚àß F ‚àß V = **F** ‚úó Acc√®s refus√© (manque la permission)

#### √âtape 4 : Impl√©mentation en JavaScript

Voici comment impl√©menter ce syst√®me de contr√¥le d'acc√®s en utilisant un middleware Express :

```javascript
const express = require('express');
const jwt = require('jsonwebtoken');

const app = express();

// Middleware de v√©rification d'acc√®s
const checkAdminAccess = (req, res, next) => {
  // Proposition p : L'utilisateur est authentifi√©
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    // p = false, donc la formule compl√®te est fausse
    return res.status(401).json({ error: 'Non authentifi√©' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = decoded.user;
    
    // p est maintenant vrai, continuons avec les autres propositions
    
    // Proposition q : r√¥le admin
    const isAdmin = user.role === 'admin';
    
    // Proposition r : r√¥le moderator
    const isModerator = user.role === 'moderator';
    
    // Proposition s : permission manage_users
    const hasManageUsersPermission = user.permissions?.includes('manage_users');
    
    // Proposition t : requ√™te modifie des donn√©es
    const isModifyingRequest = ['POST', 'PUT', 'DELETE'].includes(req.method);
    
    // Proposition u : compte en lecture seule
    const isReadOnly = user.readOnly === true;
    
    // √âvaluation de la formule : p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u)
    
    // Partie 1 : p (d√©j√† v√©rifi√©, on est dans le try)
    const authenticated = true;
    
    // Partie 2 : q ‚à® (r ‚àß s)
    const hasRoleAccess = isAdmin || (isModerator && hasManageUsersPermission);
    
    // Partie 3 : t ‚Üí ¬¨u, √©quivalent √† ¬¨t ‚à® ¬¨u
    const notModifyingOrNotReadOnly = !isModifyingRequest || !isReadOnly;
    
    // Formule compl√®te
    const hasAccess = authenticated && hasRoleAccess && notModifyingOrNotReadOnly;
    
    if (!hasAccess) {
      // Fournir un message d'erreur d√©taill√© bas√© sur quelle partie a √©chou√©
      if (!hasRoleAccess) {
        return res.status(403).json({ 
          error: 'Privil√®ges insuffisants',
          details: 'Vous devez √™tre admin ou mod√©rateur avec la permission manage_users'
        });
      }
      if (!notModifyingOrNotReadOnly) {
        return res.status(403).json({ 
          error: 'Compte en lecture seule',
          details: 'Votre compte ne peut pas modifier des donn√©es'
        });
      }
    }
    
    // L'acc√®s est autoris√©
    req.user = user;
    next();
    
  } catch (error) {
    return res.status(401).json({ error: 'Token invalide' });
  }
};

// Utilisation du middleware
app.get('/api/admin/users', checkAdminAccess, (req, res) => {
  // Logique pour r√©cup√©rer les utilisateurs
  res.json({ users: [] });
});

app.post('/api/admin/users', checkAdminAccess, (req, res) => {
  // Logique pour cr√©er un utilisateur
  res.json({ message: 'Utilisateur cr√©√©' });
});
```

#### √âtape 5 : Simplification et optimisation

Analysons si notre formule peut √™tre simplifi√©e. La formule est :

**p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u)**

Rappelons que t ‚Üí ¬¨u ‚â° ¬¨t ‚à® ¬¨u

Donc : **p ‚àß (q ‚à® (r ‚àß s)) ‚àß (¬¨t ‚à® ¬¨u)**

Cette forme est d√©j√† relativement optimis√©e. Cependant, on pourrait appliquer la loi de distributivit√© si n√©cessaire, mais dans ce cas, la forme actuelle est la plus claire et correspond bien √† la logique m√©tier.

#### √âtape 6 : Tests unitaires bas√©s sur la logique

```javascript
const assert = require('assert');

describe('Logique de contr√¥le d\'acc√®s', () => {
  it('devrait autoriser un admin authentifi√© pour une requ√™te GET', () => {
    const p = true;   // authentifi√©
    const q = true;   // admin
    const r = false;  // moderator
    const s = false;  // permission
    const t = false;  // modifie
    const u = false;  // lecture seule
    
    const hasAccess = p && (q || (r && s)) && (!t || !u);
    assert.strictEqual(hasAccess, true);
  });
  
  it('devrait refuser un moderator sans permission', () => {
    const p = true;   // authentifi√©
    const q = false;  // admin
    const r = true;   // moderator
    const s = false;  // permission (manquante)
    const t = false;  // modifie
    const u = false;  // lecture seule
    
    const hasAccess = p && (q || (r && s)) && (!t || !u);
    assert.strictEqual(hasAccess, false);
  });
  
  it('devrait refuser un compte en lecture seule pour une requ√™te POST', () => {
    const p = true;   // authentifi√©
    const q = true;   // admin
    const r = false;  // moderator
    const s = false;  // permission
    const t = true;   // modifie (POST)
    const u = true;   // lecture seule
    
    const hasAccess = p && (q || (r && s)) && (!t || !u);
    assert.strictEqual(hasAccess, false);
  });
});
```

#### Connexion avec PostgreSQL

La m√™me logique peut √™tre appliqu√©e dans des requ√™tes SQL. Par exemple, pour v√©rifier les permissions c√¥t√© base de donn√©es :

```sql
-- Cr√©er une fonction qui v√©rifie les permissions
CREATE OR REPLACE FUNCTION check_user_access(
    user_id INTEGER,
    is_modifying BOOLEAN
) RETURNS BOOLEAN AS $$
DECLARE
    p BOOLEAN;  -- authentifi√© (implicite si on a l'user_id)
    q BOOLEAN;  -- est admin
    r BOOLEAN;  -- est moderator
    s BOOLEAN;  -- a la permission
    t BOOLEAN;  -- modifie
    u BOOLEAN;  -- lecture seule
    result BOOLEAN;
BEGIN
    -- R√©cup√©rer les informations de l'utilisateur
    SELECT 
        true,  -- p (authentifi√©)
        (role = 'admin'),  -- q
        (role = 'moderator'),  -- r
        ('manage_users' = ANY(permissions)),  -- s
        is_modifying,  -- t
        read_only  -- u
    INTO p, q, r, s, t, u
    FROM users
    WHERE id = user_id;
    
    -- Appliquer la formule : p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u)
    -- En SQL : p AND (q OR (r AND s)) AND (NOT t OR NOT u)
    result := p AND (q OR (r AND s)) AND (NOT t OR NOT u);
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Utilisation
SELECT check_user_access(42, true);  -- V√©rifie l'acc√®s pour l'utilisateur 42 avec modification
```

#### Analyse de la complexit√©

La formule p ‚àß (q ‚à® (r ‚àß s)) ‚àß (t ‚Üí ¬¨u) n√©cessite d'√©valuer au maximum 6 propositions atomiques. Cependant, gr√¢ce √† l'**√©valuation en court-circuit** (short-circuit evaluation) en JavaScript :

- Si p est faux, l'ensemble de la conjonction est faux sans √©valuer le reste
- Si (q ‚à® (r ‚àß s)) est faux, on peut arr√™ter imm√©diatement
- JavaScript √©value les op√©rateurs && et || de gauche √† droite et s'arr√™te d√®s que le r√©sultat est d√©termin√©

Dans le pire cas (tous les tests doivent √™tre effectu√©s), on a une complexit√© temporelle O(1) avec un nombre constant d'op√©rations.

---

## üéØ Exercices appliqu√©s

### Exercice 1 : Niveau Facile - Construction de table de v√©rit√©

**√ânonc√©** : Construisez la table de v√©rit√© compl√®te pour la formule suivante :

**(p ‚Üí q) ‚àß (q ‚Üí r)**

Ensuite, d√©terminez si cette formule est une tautologie, une contradiction, ou une contingence.

**Crit√®res d'√©valuation** :
- Identification correcte du nombre de lignes n√©cessaires (2 points)
- Construction correcte de toutes les colonnes interm√©diaires (3 points)
- Calcul correct de la colonne finale (3 points)
- Classification correcte de la formule (2 points)

**Indice** : Vous avez 3 variables (p, q, r), donc vous aurez besoin de 2¬≥ = 8 lignes. Pensez √† calculer d'abord p ‚Üí q, puis q ‚Üí r, avant de faire leur conjonction. Rappelez-vous qu'une implication n'est fausse que lorsque l'ant√©c√©dent est vrai et le cons√©quent est faux.

**Solution** :

| p | q | r | p ‚Üí q | q ‚Üí r | (p ‚Üí q) ‚àß (q ‚Üí r) |
|---|---|---|-------|-------|-------------------|
| V | V | V | V     | V     | V                 |
| V | V | F | V     | F     | F                 |
| V | F | V | F     | V     | F                 |
| V | F | F | F     | V     | F                 |
| F | V | V | V     | V     | V                 |
| F | V | F | V     | F     | F                 |
| F | F | V | V     | V     | V                 |
| F | F | F | V     | V     | V                 |

**Analyse** :
- La formule est vraie dans 4 cas sur 8 et fausse dans 4 cas sur 8.
- Ce n'est donc ni une tautologie (pas toujours vraie), ni une contradiction (pas toujours fausse).
- C'est une **contingence**.

**Remarque int√©ressante** : Cette formule repr√©sente le **syllogisme hypoth√©tique** : "Si p implique q, et q implique r, alors la formule est vraie". Notez que lorsque p est vrai et r est faux (lignes 2, 3, 4), la formule est fausse, ce qui est logique : on ne peut pas avoir p vrai, r faux, et maintenir les deux implications simultan√©ment.

---

### Exercice 2 : Niveau Moyen - Application des lois de De Morgan

**√ânonc√©** : Dans votre code JavaScript, vous avez la condition suivante :

```javascript
if (!(isUserAdmin && hasActiveSubscription) || isInTrialPeriod) {
    allowAccess();
}
```

Votre coll√®gue trouve cette condition difficile √† lire √† cause de la n√©gation au d√©but. En utilisant les lois de De Morgan et les autres lois logiques, simplifiez cette expression pour √©liminer la n√©gation de la premi√®re partie.

Ensuite, √©crivez les deux versions du code (originale et simplifi√©e) et v√©rifiez qu'elles sont √©quivalentes en construisant une table de v√©rit√©.

**Crit√®res d'√©valuation** :
- Application correcte de la loi de De Morgan (3 points)
- Simplification correcte de l'expression compl√®te (3 points)
- Code JavaScript syntaxiquement correct pour les deux versions (2 points)
- Table de v√©rit√© d√©montrant l'√©quivalence (2 points)

**Indice** : Commencez par appliquer la loi de De Morgan √† !(isUserAdmin && hasActiveSubscription). Ensuite, observez la structure g√©n√©rale de l'expression : c'est une disjonction (OR) entre deux parties.

**Solution** :

**√âtape 1** : Identifions les propositions
- p : isUserAdmin
- q : hasActiveSubscription
- r : isInTrialPeriod

**Expression originale** : ¬¨(p ‚àß q) ‚à® r

**√âtape 2** : Application de De Morgan sur ¬¨(p ‚àß q)
- ¬¨(p ‚àß q) ‚â° ¬¨p ‚à® ¬¨q

**√âtape 3** : Substitution dans l'expression compl√®te
- ¬¨(p ‚àß q) ‚à® r ‚â° (¬¨p ‚à® ¬¨q) ‚à® r

**√âtape 4** : Simplification par associativit√©
- (¬¨p ‚à® ¬¨q) ‚à® r ‚â° ¬¨p ‚à® ¬¨q ‚à® r

**Code JavaScript simplifi√©** :
```javascript
// Version originale
if (!(isUserAdmin && hasActiveSubscription) || isInTrialPeriod) {
    allowAccess();
}

// Version simplifi√©e (√©quivalente)
if (!isUserAdmin || !hasActiveSubscription || isInTrialPeriod) {
    allowAccess();
}
```

**V√©rification par table de v√©rit√©** :

| p | q | r | p ‚àß q | ¬¨(p ‚àß q) | ¬¨(p ‚àß q) ‚à® r | ¬¨p | ¬¨q | ¬¨p ‚à® ¬¨q ‚à® r |
|---|---|---|-------|----------|--------------|----|----|-------------|
| V | V | V | V     | F        | V            | F  | F  | V           |
| V | V | F | V     | F        | F            | F  | F  | F           |
| V | F | V | F     | V        | V            | F  | V  | V           |
| V | F | F | F     | V        | V            | F  | V  | V           |
| F | V | V | F     | V        | V            | V  | F  | V           |
| F | V | F | F     | V        | V            | V  | F  | V           |
| F | F | V | F     | V        | V            | V  | V  | V           |
| F | F | F | F     | V        | V            | V  | V  | V           |

Les colonnes "¬¨(p ‚àß q) ‚à® r" et "¬¨p ‚à® ¬¨q ‚à® r" sont identiques, confirmant l'√©quivalence.

**Interpr√©tation** : La version simplifi√©e est plus lisible car elle exprime directement : "Accorder l'acc√®s si l'utilisateur n'est pas admin, OU n'a pas d'abonnement actif, OU est en p√©riode d'essai". Cette forme positive est g√©n√©ralement plus facile √† comprendre que la forme avec n√©gation.

---

### Exercice 3 : Niveau Difficile - Conception d'un syst√®me de permissions complexe

**√ânonc√©** : Vous devez concevoir un syst√®me de permissions pour une application de gestion de projets. Les r√®gles sont complexes et doivent √™tre impl√©ment√©es avec pr√©cision.

**R√®gles m√©tier** :
1. Un utilisateur peut voir un projet SI :
   - Il est le propri√©taire du projet, OU
   - Il est membre de l'√©quipe du projet, OU
   - Le projet est public

2. Un utilisateur peut modifier un projet SI :
   - (Il est le propri√©taire du projet OU il est admin de l'organisation) ET
   - Le projet n'est pas archiv√©

3. Un utilisateur peut supprimer un projet SI :
   - Il est le propri√©taire du projet ET
   - (Il est admin de l'organisation OU le projet a √©t√© cr√©√© il y a moins de 24 heures) ET
   - Le projet n'a pas de tickets ouverts

**T√¢ches** :
a) Traduisez chaque r√®gle en une formule logique propositionnelle en d√©finissant clairement vos variables.

b) Simplifiez les formules autant que possible en utilisant les lois logiques.

c) Impl√©mentez ces r√®gles en JavaScript sous forme de fonctions pures qui retournent un bool√©en.

d) Cr√©ez au moins 5 tests unitaires qui couvrent des cas limites int√©ressants.

e) Analysez la complexit√© de votre impl√©mentation et proposez une optimisation si possible.

**Crit√®res d'√©valuation** :
- Traduction correcte des r√®gles en formules logiques avec variables bien d√©finies (3 points)
- Simplification correcte des formules (2 points)
- Impl√©mentation JavaScript correcte et √©l√©gante (3 points)
- Tests unitaires pertinents et complets (1 point)
- Analyse de complexit√© et optimisation (1 point)

**Indice** : Pour les r√®gles 2 et 3, faites attention aux priorit√©s des op√©rateurs. Utilisez des parenth√®ses pour √™tre certain de l'ordre d'√©valuation. Pour l'optimisation, pensez √† l'√©valuation en court-circuit : ordonnez vos conditions de la plus probable de court-circuiter √† la moins probable.

*Note : Cet exercice ne contient pas de solution fournie pour vous permettre de le travailler en autonomie. Vous pouvez v√©rifier votre r√©ponse en construisant des tables de v√©rit√© partielles pour des cas sp√©cifiques.*

---

## üìö Ressources recommand√©es

Les ressources suivantes sont class√©es par ordre de priorit√© pour approfondir votre compr√©hension de la logique propositionnelle :

### Ressource 1 (Priorit√© maximale) : Livre de r√©f√©rence
**Type** : Livre acad√©mique  
**Titre** : "Mathematics for Computer Science"  
**Auteurs** : Eric Lehman, F. Thomson Leighton, Albert R. Meyer (MIT)  
**Disponibilit√©** : Gratuit en ligne sur le site du MIT OpenCourseWare  
**Sections pertinentes** : Chapitre 1 (Proofs), Chapitre 3 (Logic)

**Pourquoi cette ressource est recommand√©e** : Ce livre est le manuel officiel du cours MIT 6.042J, l'√©quivalent exact de ce que nous √©tudions. Le chapitre sur la logique couvre la logique propositionnelle avec une rigueur math√©matique tout en restant accessible. Les exemples sont nombreux et les exercices gradu√©s en difficult√©. C'est la r√©f√©rence absolue pour ce sujet.

---

### Ressource 2 (Priorit√© haute) : Cours en ligne interactif
**Type** : Cours en ligne  
**Titre** : "Introduction to Mathematical Thinking" - Stanford Online  
**Auteur** : Keith Devlin  
**Plateforme** : Coursera  

**Pourquoi cette ressource est recommand√©e** : Bien que ce cours couvre plus que la simple logique propositionnelle, les premi√®res semaines offrent une excellente introduction au raisonnement logique formel avec des vid√©os claires et des quiz interactifs. Le style p√©dagogique de Keith Devlin est particuli√®rement appr√©ci√© pour rendre la logique formelle accessible.

---

### Ressource 3 (Priorit√© moyenne-haute) : Tutoriel interactif
**Type** : Tutoriel web interactif  
**Titre** : "Propositional Logic" sur Brilliant.org  
**Plateforme** : Brilliant.org  

**Pourquoi cette ressource est recommand√©e** : Brilliant offre une approche tr√®s interactive avec des exercices imm√©diats et des explications visuelles. C'est particuli√®rement utile pour comprendre les tables de v√©rit√© et les simplifications logiques √† travers la pratique. L'approche "learning by doing" compl√®te bien la th√©orie vue dans cette le√ßon.

---

### Ressource 4 (Priorit√© moyenne) : Documentation technique
**Type** : Documentation MDN  
**Titre** : "Logical operators" - MDN Web Docs  
**URL** : Documentation Mozilla sur les op√©rateurs logiques JavaScript  

**Pourquoi cette ressource est recommand√©e** : Pour ancrer la logique propositionnelle dans votre pratique quotidienne de d√©veloppeur JavaScript, la documentation MDN sur les op√©rateurs logiques est incontournable. Elle explique les subtilit√©s de JavaScript (truthiness, short-circuit evaluation) qui sont directement li√©es aux concepts logiques vus dans cette le√ßon.

---

### Ressource 5 (Priorit√© moyenne) : Outil pratique
**Type** : Outil en ligne  
**Titre** : "Truth Table Generator"  
**Plusieurs options disponibles** : Recherchez "truth table generator" pour trouver divers outils gratuits  

**Pourquoi cette ressource est recommand√©e** : Ces g√©n√©rateurs de tables de v√©rit√© permettent de v√©rifier rapidement vos r√©ponses aux exercices et d'explorer des formules complexes. C'est un excellent outil pour d√©velopper votre intuition en testant rapidement diff√©rentes formules et en observant leurs tables de v√©rit√©. Attention cependant √† ne pas en devenir d√©pendant : l'objectif est d'apprendre √† construire les tables vous-m√™me.

---

### Ressource 6 (Priorit√© basse - pour aller plus loin) : Livre avanc√©
**Type** : Livre  
**Titre** : "A Mathematical Introduction to Logic"  
**Auteur** : Herbert B. Enderton  
**√âditeur** : Academic Press  

**Pourquoi cette ressource est recommand√©e** : Si vous souhaitez approfondir significativement au-del√† du scope de cette le√ßon, ce livre offre une pr√©sentation rigoureuse et compl√®te de la logique math√©matique. Il va bien au-del√† de la logique propositionnelle, mais les premiers chapitres fournissent une base solide avec de nombreux th√©or√®mes et preuves formelles. R√©serv√© aux √©tudiants qui souhaitent une compr√©hension tr√®s approfondie.

---

## üìä Grille d'√©valuation

Cette grille vous permet d'√©valuer votre ma√Ætrise de la le√ßon sur un total de 20 points.

### Crit√®re 1 : Compr√©hension des concepts fondamentaux (5 points)

**3 points** : Capacit√© √† d√©finir pr√©cis√©ment ce qu'est une proposition, identifier correctement les cinq connecteurs logiques, et expliquer la notion de valeur de v√©rit√©.

**2 points** : Compr√©hension g√©n√©rale des concepts mais avec des impr√©cisions dans les d√©finitions ou confusion occasionnelle entre certains connecteurs.

**1 point** : Compr√©hension partielle, incapacit√© √† distinguer clairement tous les connecteurs ou erreurs dans la d√©finition de proposition.

**0 point** : Incompr√©hension des concepts de base.

---

### Crit√®re 2 : Construction de tables de v√©rit√© (5 points)

**5 points** : Capacit√© √† construire correctement et syst√©matiquement des tables de v√©rit√© pour des formules comportant 3 variables ou plus, avec toutes les colonnes interm√©diaires appropri√©es et aucune erreur de calcul.

**4 points** : Construction g√©n√©ralement correcte avec au plus une erreur mineure dans le calcul des valeurs, ou absence d'une colonne interm√©diaire qui n'affecte pas le r√©sultat final.

**3 points** : Construction correcte pour des formules simples (2 variables) mais erreurs pour des formules plus complexes, ou oubli de plusieurs combinaisons de valeurs.

**2 points** : Comprend le principe g√©n√©ral mais fait des erreurs syst√©matiques dans l'application des connecteurs (confusion entre ‚àß et ‚à®, erreurs sur l'implication).

**1 point** : Tentative de construction avec structure globale correcte mais nombreuses erreurs de calcul.

**0 point** : Incapacit√© √† construire une table de v√©rit√© m√™me simple.

---

### Crit√®re 3 : Application des lois logiques (4 points)

**4 points** : Ma√Ætrise compl√®te des lois logiques (De Morgan, distributivit√©, etc.) avec capacit√© √† les appliquer correctement pour simplifier des expressions complexes et d√©montrer des √©quivalences.

**3 points** : Capable d'appliquer les principales lois (De Morgan, double n√©gation) mais difficult√© avec les lois plus avanc√©es (distributivit√©, absorption).

**2 points** : Connaissance th√©orique des lois mais difficult√© √† les appliquer correctement dans des situations concr√®tes.

**1 point** : Connaissance partielle de quelques lois sans r√©elle capacit√© d'application.

**0 point** : Aucune ma√Ætrise des lois logiques.

---

### Crit√®re 4 : Traduction entre langage naturel et formules (3 points)

**3 points** : Capacit√© √† traduire correctement des √©nonc√©s en langage naturel vers des formules propositionnelles et inversement, en identifiant correctement les connecteurs implicites et la structure logique.

**2 points** : Traduction g√©n√©ralement correcte pour des √©nonc√©s simples mais difficult√© avec des √©nonc√©s complexes ou ambigus (par exemple, confusion entre "ou inclusif" et "ou exclusif").

**1 point** : Traduction approximative avec erreurs fr√©quentes dans l'identification des connecteurs appropri√©s.

**0 point** : Incapacit√© √† √©tablir le lien entre langage naturel et notation formelle.

---

### Crit√®re 5 : Impl√©mentation en JavaScript (3 points)

**3 points** : Code JavaScript syntaxiquement correct, utilisant les op√©rateurs logiques appropri√©s, avec gestion correcte des priorit√©s et commentaires explicatifs. Le code respecte les bonnes pratiques (const/let, noms de variables significatifs).

**2 points** : Code fonctionnel mais avec des probl√®mes mineurs de style, des priorit√©s d'op√©rateurs non optimales (utilisation excessive de parenth√®ses), ou absence de commentaires.

**1 point** : Code avec erreurs syntaxiques mineures ou logique incorrecte, mais d√©monstration d'une compr√©hension partielle de la correspondance entre logique et code.

**0 point** : Code non fonctionnel ou absence totale de correspondance entre la logique propositionnelle et l'impl√©mentation.

---

### Bar√®me de notation global

**18-20 points** : Excellent. Ma√Ætrise compl√®te de la logique propositionnelle avec capacit√© √† appliquer les concepts dans des contextes vari√©s.

**15-17 points** : Tr√®s bien. Bonne compr√©hension globale avec quelques lacunes mineures sur des points avanc√©s.

**12-14 points** : Bien. Compr√©hension solide des concepts de base mais difficult√© avec les applications complexes.

**10-11 points** : Passable. Compr√©hension partielle suffisante pour progresser mais n√©cessite un travail suppl√©mentaire sur les exercices.

**< 10 points** : Insuffisant. R√©vision n√©cessaire avant de passer √† la le√ßon suivante.

---

## üéì Conclusion de la le√ßon

F√©licitations ! Vous avez compl√©t√© votre premi√®re le√ßon de Computer Science formelle. La logique propositionnelle constitue la fondation de tout raisonnement math√©matique et informatique rigoureux.

**Concepts cl√©s √† retenir** :
- Une proposition a toujours une valeur de v√©rit√© (vrai ou faux)
- Les cinq connecteurs fondamentaux (¬¨, ‚àß, ‚à®, ‚Üí, ‚Üî) permettent de construire des formules complexes
- Les tables de v√©rit√© sont l'outil fondamental pour analyser les formules propositionnelles
- Les lois logiques (surtout De Morgan) permettent de transformer et simplifier les expressions
- La logique propositionnelle s'applique directement en programmation via les op√©rateurs bool√©ens

**Prochaines √©tapes** : Dans la le√ßon suivante (M1.C1.L2 - Logique des pr√©dicats et quantificateurs), nous √©tendrons la logique propositionnelle pour traiter des √©nonc√©s plus complexes impliquant des variables et des quantificateurs (‚àÄ "pour tout" et ‚àÉ "il existe"). Cela vous permettra d'exprimer des propri√©t√©s sur des ensembles d'objets, essentiel pour raisonner sur des structures de donn√©es et des algorithmes.

**Conseil pour bien assimiler** : Pratiquez r√©guli√®rement en identifiant la logique propositionnelle dans votre code quotidien. Chaque fois que vous √©crivez une condition if complexe, essayez de la traduire en formule logique et v√©rifiez si elle peut √™tre simplifi√©e. Cette connexion constante entre th√©orie et pratique est la cl√© d'une ma√Ætrise solide.

---

**Derni√®re mise √† jour** : Janvier 2026  
**Auteur** : Curriculum Computer Science - Version 1.0