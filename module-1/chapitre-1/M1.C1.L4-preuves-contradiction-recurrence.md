# ğŸ“š Module 1 - Chapitre 1 - LeÃ§on 4
# Preuve par contradiction et par rÃ©currence

---

## ğŸ“‹ MÃ©tadonnÃ©es de la leÃ§on

**Identifiant** : M1.C1.L4  
**Titre** : Preuve par contradiction et par rÃ©currence  
**PrÃ©requis** : M1.C1.L3 (Techniques de preuve : preuve directe et contraposÃ©e)  
**Temps d'Ã©tude estimÃ©** : 6 heures

---

## ğŸ¯ Objectifs d'apprentissage

Ã€ la fin de cette leÃ§on, vous serez capable de :

1. **MaÃ®triser la technique de preuve par contradiction** en supposant la nÃ©gation de ce que l'on veut prouver et en dÃ©rivant une contradiction logique, tout en comprenant pourquoi cette mÃ©thode est valide et quand l'utiliser.

2. **Construire des preuves par l'absurde** pour Ã©tablir l'existence ou l'unicitÃ© d'objets mathÃ©matiques, en identifiant clairement l'hypothÃ¨se absurde, la contradiction obtenue, et la conclusion qui en dÃ©coule.

3. **Appliquer le principe d'induction mathÃ©matique** (induction simple) pour prouver des propriÃ©tÃ©s sur les entiers naturels, en Ã©tablissant correctement le cas de base et l'Ã©tape d'induction avec l'hypothÃ¨se d'induction explicite.

4. **Utiliser l'induction forte** (principe d'induction complÃ¨te) pour prouver des propriÃ©tÃ©s oÃ¹ l'Ã©tape inductive nÃ©cessite plus qu'un seul cas prÃ©cÃ©dent, en comprenant la diffÃ©rence avec l'induction simple.

5. **Prouver la correction d'algorithmes rÃ©cursifs** en utilisant l'induction mathÃ©matique comme technique naturelle correspondant Ã  la structure rÃ©cursive du code.

6. **Identifier les piÃ¨ges et erreurs communes** dans les preuves par induction, notamment l'oubli du cas de base, l'hypothÃ¨se d'induction mal formulÃ©e, ou le raisonnement circulaire dans l'Ã©tape inductive.

---

## ğŸ“– Contenu exhaustif de la leÃ§on

### ğŸ” 1. Preuve par contradiction : principe et fondement logique

La preuve par contradiction, Ã©galement appelÃ©e **reductio ad absurdum** (rÃ©duction Ã  l'absurde), est une technique de preuve extrÃªmement puissante qui repose sur un principe logique fondamental. Imaginez que vous voulez prouver qu'une porte est verrouillÃ©e. Une approche serait d'essayer de l'ouvrir directement (preuve directe). Mais vous pourriez aussi raisonner ainsi : "Supposons que la porte ne soit pas verrouillÃ©e. Alors je pourrais l'ouvrir. Mais j'ai essayÃ© et elle ne s'ouvre pas, contradiction. Donc la porte doit Ãªtre verrouillÃ©e." C'est exactement le principe de la preuve par contradiction.

#### Fondement logique : loi du tiers exclu

La preuve par contradiction repose sur la **loi du tiers exclu** (en latin : *tertium non datur*), un axiome fondamental de la logique classique qui Ã©nonce : pour toute proposition P, soit P est vraie, soit Â¬P est vraie, et il n'y a pas de troisiÃ¨me possibilitÃ©.

Formellement : P âˆ¨ Â¬P (P ou non-P) est toujours vrai.

Cette loi peut sembler Ã©vidente, mais elle a des implications profondes. Elle nous permet de raisonner ainsi : si nous voulons prouver P, nous pouvons supposer Â¬P et montrer que cette supposition mÃ¨ne Ã  une contradiction. Puisque Â¬P ne peut pas Ãªtre vrai (il mÃ¨ne Ã  une contradiction), et puisque P âˆ¨ Â¬P doit Ãªtre vrai, alors P doit Ãªtre vrai.

#### Structure formelle d'une preuve par contradiction

Pour prouver un Ã©noncÃ© P par contradiction :

**Ã‰tape 1** : Supposer explicitement que P est faux, c'est-Ã -dire supposer Â¬P.

**Ã‰tape 2** : Ã€ partir de Â¬P (et Ã©ventuellement d'autres hypothÃ¨ses ou faits connus), dÃ©duire une sÃ©quence d'implications logiques.

**Ã‰tape 3** : Arriver Ã  une contradiction, c'est-Ã -dire Ã  un Ã©noncÃ© de la forme Q âˆ§ Â¬Q (quelque chose et son contraire), ou Ã  une affirmation qui contredit un fait Ã©tabli, une hypothÃ¨se, ou un axiome.

**Ã‰tape 4** : Conclure que l'hypothÃ¨se Â¬P doit Ãªtre fausse, donc P doit Ãªtre vrai.

#### Template formel

```
ThÃ©orÃ¨me : P est vrai.

Preuve (par contradiction) :
  Supposons, pour obtenir une contradiction, que P soit faux.
  [C'est-Ã -dire, supposons Â¬P]
  
  [DÃ©veloppement de Â¬P]
  ...
  [SÃ©rie de dÃ©ductions]
  ...
  
  Nous obtenons Q.
  Mais nous avons aussi Â¬Q [ou Q contredit un fait connu].
  
  Ceci est une contradiction.
  
  Par consÃ©quent, notre hypothÃ¨se Ã©tait fausse.
  Donc P est vrai.
âˆ
```

#### Ce qui constitue une "contradiction"

Une contradiction peut prendre plusieurs formes :

**Forme 1 - Contradiction directe** : Nous dÃ©duisons Ã  la fois Q et Â¬Q pour un certain Ã©noncÃ© Q. Par exemple, nous montrons qu'un nombre n est Ã  la fois pair et impair.

**Forme 2 - Contradiction avec un fait connu** : Nous dÃ©duisons quelque chose qui contredit un thÃ©orÃ¨me Ã©tabli ou un axiome. Par exemple, nous obtenons 1 = 0, ou nous obtenons qu'un nombre premier est divisible par un autre nombre premier.

**Forme 3 - Contradiction avec les hypothÃ¨ses** : Nous dÃ©duisons quelque chose qui contredit une des hypothÃ¨ses de dÃ©part. Par exemple, si l'hypothÃ¨se est "n est positif" et nous dÃ©duisons "n < 0", c'est une contradiction.

**Forme 4 - Violation d'une propriÃ©tÃ© fondamentale** : Nous dÃ©duisons quelque chose qui viole une propriÃ©tÃ© de base des objets mathÃ©matiques. Par exemple, nous trouvons un ensemble qui se contient lui-mÃªme (paradoxe de Russell), ou un entier strictement entre 0 et 1.

#### DiffÃ©rence avec la preuve par contraposÃ©e

Il est important de ne pas confondre preuve par contradiction et preuve par contraposÃ©e, bien qu'elles soient liÃ©es.

**Preuve par contraposÃ©e de P â†’ Q** : On prouve Â¬Q â†’ Â¬P. On suppose Â¬Q et on dÃ©duit Â¬P. C'est une preuve directe de la contraposÃ©e.

**Preuve par contradiction de P â†’ Q** : On suppose P âˆ§ Â¬Q (l'antÃ©cÃ©dent est vrai mais le consÃ©quent est faux) et on dÃ©duit une contradiction.

Pour une implication P â†’ Q, ces deux approches sont souvent similaires en pratique, mais conceptuellement diffÃ©rentes. La preuve par contraposÃ©e reste une preuve "constructive" de Â¬Q â†’ Â¬P, tandis que la preuve par contradiction est "non-constructive" : elle ne construit pas directement Q Ã  partir de P, elle montre seulement que Â¬Q est impossible.

Pour prouver un Ã©noncÃ© simple (non une implication) P, la preuve par contradiction est l'approche naturelle : on suppose Â¬P et on cherche une contradiction.

---

### ğŸ“ 2. Exemples classiques de preuves par contradiction

Certaines preuves par contradiction sont devenues des classiques de l'histoire des mathÃ©matiques. Ã‰tudions-les en dÃ©tail.

#### Exemple fondamental : IrrationnalitÃ© de âˆš2

Ce thÃ©orÃ¨me, dÃ©couvert par les Pythagoriciens dans l'AntiquitÃ© grecque, a Ã©tÃ© un choc philosophique pour les mathÃ©maticiens de l'Ã©poque qui croyaient que tous les nombres pouvaient s'exprimer comme rapports d'entiers.

**ThÃ©orÃ¨me** : âˆš2 est irrationnel.

**Rappel** : Un nombre est rationnel s'il peut s'Ã©crire sous la forme p/q oÃ¹ p et q sont des entiers et q â‰  0. Un nombre est irrationnel s'il n'est pas rationnel.

**Preuve par contradiction** :

Supposons, pour obtenir une contradiction, que âˆš2 soit rationnel.

Alors, par dÃ©finition, il existe des entiers p et q (avec q â‰  0) tels que :

âˆš2 = p/q

Nous pouvons supposer sans perte de gÃ©nÃ©ralitÃ© que cette fraction est sous forme rÃ©duite, c'est-Ã -dire que p et q n'ont aucun diviseur commun autre que 1. (Si ce n'Ã©tait pas le cas, on pourrait simplifier la fraction.)

En Ã©levant au carrÃ© les deux cÃ´tÃ©s :
2 = pÂ²/qÂ²

En multipliant par qÂ² :
2qÂ² = pÂ²

Cela signifie que pÂ² est pair (car pÂ² = 2qÂ², un multiple de 2).

Or, si pÂ² est pair, alors p doit Ãªtre pair. (Nous avons prouvÃ© ce rÃ©sultat dans la leÃ§on M1.C1.L3 par contraposÃ©e : si n est impair, alors nÂ² est impair ; donc si nÂ² est pair, alors n est pair.)

Puisque p est pair, il existe un entier k tel que p = 2k.

En substituant dans l'Ã©quation 2qÂ² = pÂ² :
2qÂ² = (2k)Â²
2qÂ² = 4kÂ²
qÂ² = 2kÂ²

Cela signifie que qÂ² est pair, donc q est pair (par le mÃªme raisonnement que pour p).

Nous avons donc montrÃ© que p et q sont tous les deux pairs.

Mais cela signifie qu'ils ont 2 comme diviseur commun.

Ceci contredit notre hypothÃ¨se que p/q Ã©tait sous forme rÃ©duite (sans diviseur commun autre que 1).

Nous avons obtenu une contradiction.

Par consÃ©quent, notre hypothÃ¨se de dÃ©part Ã©tait fausse : âˆš2 ne peut pas Ãªtre rationnel.

Donc âˆš2 est irrationnel. âˆ

**Analyse de la preuve** : Cette preuve est remarquable par son Ã©lÃ©gance. La contradiction finale est avec notre hypothÃ¨se technique (la fraction est rÃ©duite), pas avec une contradiction arithmÃ©tique directe. C'est une stratÃ©gie courante : on ajoute une hypothÃ¨se auxiliaire qui permet d'obtenir plus facilement une contradiction.

#### Exemple : Infinitude des nombres premiers

Un autre chef-d'Å“uvre de preuve par contradiction, dÃ» Ã  Euclide (vers 300 avant J.-C.).

**ThÃ©orÃ¨me** : Il existe une infinitÃ© de nombres premiers.

**Preuve par contradiction** :

Supposons, pour obtenir une contradiction, qu'il existe seulement un nombre fini de nombres premiers.

Listons-les tous : pâ‚, pâ‚‚, pâ‚ƒ, ..., pâ‚™ oÃ¹ n est un entier fixÃ© et pâ‚, pâ‚‚, ..., pâ‚™ sont tous les nombres premiers qui existent.

ConsidÃ©rons le nombre N dÃ©fini par :
N = (pâ‚ Ã— pâ‚‚ Ã— pâ‚ƒ Ã— ... Ã— pâ‚™) + 1

C'est-Ã -dire, N est le produit de tous les nombres premiers, plus 1.

Remarquons que N > 1, donc N a au moins un diviseur premier (par le thÃ©orÃ¨me fondamental de l'arithmÃ©tique, tout entier > 1 est soit premier, soit produit de nombres premiers).

Appelons q ce diviseur premier de N.

Puisque nous avons supposÃ© que pâ‚, pâ‚‚, ..., pâ‚™ sont tous les nombres premiers, q doit Ãªtre l'un d'entre eux. Donc q = páµ¢ pour un certain i âˆˆ {1, 2, ..., n}.

Puisque q divise N, nous avons N = q Ã— m pour un certain entier m.

Mais q divise Ã©galement le produit pâ‚ Ã— pâ‚‚ Ã— ... Ã— pâ‚™ (car q est l'un des facteurs de ce produit).

Donc q divise :
N - (pâ‚ Ã— pâ‚‚ Ã— ... Ã— pâ‚™) = [(pâ‚ Ã— pâ‚‚ Ã— ... Ã— pâ‚™) + 1] - (pâ‚ Ã— pâ‚‚ Ã— ... Ã— pâ‚™) = 1

Cela signifie qu'il existe un entier k tel que 1 = q Ã— k.

Puisque q est un nombre premier, nous avons q â‰¥ 2.

Donc q Ã— k â‰¥ 2k â‰¥ 2 (car k est un entier positif).

Mais nous avons q Ã— k = 1.

Donc 1 â‰¥ 2, ce qui est faux.

Nous avons obtenu une contradiction.

Par consÃ©quent, notre hypothÃ¨se Ã©tait fausse : il ne peut pas exister un nombre fini de nombres premiers.

Donc il existe une infinitÃ© de nombres premiers. âˆ

**Observation pÃ©dagogique** : Cette preuve illustre une technique puissante : construire un objet (ici N) qui est soigneusement conÃ§u pour mener Ã  une contradiction. La crÃ©ativitÃ© dans la preuve par contradiction rÃ©side souvent dans la construction astucieuse de l'objet ou de l'Ã©noncÃ© qui va gÃ©nÃ©rer la contradiction.

#### Exemple en informatique : Existence de programmes indÃ©cidables

**ThÃ©orÃ¨me** : Il existe des problÃ¨mes de dÃ©cision qui ne peuvent pas Ãªtre rÃ©solus par un algorithme.

**Contexte** : Ce thÃ©orÃ¨me, liÃ© au cÃ©lÃ¨bre problÃ¨me de l'arrÃªt, est fondamental en thÃ©orie de la calculabilitÃ©. Il Ã©tablit une limite fondamentale Ã  ce que les ordinateurs peuvent calculer.

**Preuve par contradiction (version simplifiÃ©e)** :

Supposons, pour obtenir une contradiction, que tout problÃ¨me de dÃ©cision puisse Ãªtre rÃ©solu par un algorithme.

En particulier, il existerait un algorithme HALT qui prend en entrÃ©e la description d'un programme P et une entrÃ©e I, et dÃ©cide si P termine sur l'entrÃ©e I.

Construisons maintenant un programme PARADOXE qui :
1. Prend en entrÃ©e la description d'un programme X
2. ExÃ©cute HALT(X, X) (demande si X termine sur lui-mÃªme)
3. Si HALT rÃ©pond "oui, X termine", alors PARADOXE boucle infiniment
4. Si HALT rÃ©pond "non, X ne termine pas", alors PARADOXE termine immÃ©diatement

Que se passe-t-il si nous exÃ©cutons PARADOXE sur lui-mÃªme, c'est-Ã -dire PARADOXE(PARADOXE) ?

**Cas 1** : Supposons que PARADOXE(PARADOXE) termine.
Alors HALT(PARADOXE, PARADOXE) doit rÃ©pondre "oui".
Mais par construction de PARADOXE, si HALT rÃ©pond "oui", alors PARADOXE boucle infiniment.
Donc PARADOXE(PARADOXE) ne termine pas.
Contradiction avec notre supposition.

**Cas 2** : Supposons que PARADOXE(PARADOXE) ne termine pas (boucle infiniment).
Alors HALT(PARADOXE, PARADOXE) doit rÃ©pondre "non".
Mais par construction de PARADOXE, si HALT rÃ©pond "non", alors PARADOXE termine immÃ©diatement.
Donc PARADOXE(PARADOXE) termine.
Contradiction avec notre supposition.

Dans les deux cas, nous obtenons une contradiction.

La seule faÃ§on d'Ã©viter cette contradiction est que notre hypothÃ¨se initiale soit fausse : un tel algorithme HALT ne peut pas exister.

Donc il existe des problÃ¨mes de dÃ©cision qui ne peuvent pas Ãªtre rÃ©solus par un algorithme. âˆ

**Signification profonde** : Cette preuve montre une limitation fondamentale des ordinateurs. Il n'est pas possible d'Ã©crire un programme qui pourrait analyser n'importe quel autre programme et dÃ©terminer s'il va terminer ou boucler infiniment. C'est une barriÃ¨re thÃ©orique infranchissable, pas juste une difficultÃ© pratique.

---

### ğŸ”¢ 3. Induction mathÃ©matique : principe et intuition

L'induction mathÃ©matique (ou induction simple) est probablement la technique de preuve la plus importante en informatique. Elle est particuliÃ¨rement adaptÃ©e pour prouver des propriÃ©tÃ©s sur les entiers naturels et, par extension, sur toutes les structures rÃ©cursives (listes, arbres, etc.).

#### Intuition : l'analogie du domino

Imaginez une ligne infinie de dominos. Vous voulez prouver que tous les dominos vont tomber. Comment procÃ©deriez-vous ?

Vous pourriez montrer deux choses :

1. **Le premier domino tombe** : C'est le cas de base.

2. **Si un domino tombe, alors le suivant tombe aussi** : C'est l'Ã©tape d'induction.

Si vous Ã©tablissez ces deux faits, vous pouvez conclure que tous les dominos tombent, par un effet en cascade. Le premier tombe (cas de base), donc le deuxiÃ¨me tombe (Ã©tape d'induction appliquÃ©e au premier), donc le troisiÃ¨me tombe (Ã©tape d'induction appliquÃ©e au deuxiÃ¨me), et ainsi de suite Ã  l'infini.

C'est exactement le principe de l'induction mathÃ©matique appliquÃ© aux entiers naturels.

#### Principe d'induction mathÃ©matique (forme standard)

Pour prouver qu'une propriÃ©tÃ© P(n) est vraie pour tout entier naturel n â‰¥ nâ‚€ (oÃ¹ nâ‚€ est typiquement 0 ou 1) :

**Cas de base** : Prouver que P(nâ‚€) est vrai.

**Ã‰tape d'induction** : Prouver que pour tout k â‰¥ nâ‚€, si P(k) est vrai, alors P(k+1) est vrai.

Si nous Ã©tablissons ces deux points, nous pouvons conclure que P(n) est vrai pour tout n â‰¥ nâ‚€.

#### Formulation formelle

Le principe d'induction mathÃ©matique peut s'exprimer ainsi :

[P(nâ‚€) âˆ§ âˆ€k â‰¥ nâ‚€ (P(k) â†’ P(k+1))] â†’ âˆ€n â‰¥ nâ‚€ P(n)

En mots : Si P est vrai pour nâ‚€, et si pour tout k â‰¥ nâ‚€, P(k) implique P(k+1), alors P est vrai pour tout n â‰¥ nâ‚€.

#### HypothÃ¨se d'induction

Dans l'Ã©tape d'induction, lorsque nous prouvons "si P(k) alors P(k+1)", l'Ã©noncÃ© P(k) (que nous supposons vrai) s'appelle l'**hypothÃ¨se d'induction** (ou **hypothÃ¨se de rÃ©currence**). Il est crucial de l'Ã©noncer explicitement dans votre preuve.

Beaucoup d'Ã©tudiants confondent "supposer P(k)" avec "supposer ce qu'on veut prouver". Ce n'est pas le cas ! Dans l'Ã©tape d'induction, nous ne supposons pas P(k+1) (ce serait circulaire). Nous supposons P(k) et nous prouvons P(k+1) Ã  partir de cette supposition. La diffÃ©rence est subtile mais fondamentale.

#### Template formel pour une preuve par induction

```
ThÃ©orÃ¨me : Pour tout n â‰¥ nâ‚€, P(n) est vrai.

Preuve (par induction sur n) :

  Cas de base (n = nâ‚€) :
    [VÃ©rification directe que P(nâ‚€) est vrai]
  
  Ã‰tape d'induction :
    Soit k â‰¥ nâ‚€ un entier quelconque.
    HypothÃ¨se d'induction : Supposons que P(k) soit vrai.
    [Ã‰noncez explicitement ce que signifie P(k)]
    
    Nous voulons montrer que P(k+1) est vrai.
    [Ã‰noncez ce que signifie P(k+1)]
    
    [Preuve de P(k+1) en utilisant P(k)]
    ...
    
    Donc P(k+1) est vrai.
  
  Par le principe d'induction mathÃ©matique, P(n) est vrai pour tout n â‰¥ nâ‚€.
âˆ
```

---

### ğŸ¯ 4. Exemples de preuves par induction

Voyons plusieurs exemples qui illustrent la technique et ses subtilitÃ©s.

#### Exemple fondamental : Somme des n premiers entiers

**ThÃ©orÃ¨me** : Pour tout entier n â‰¥ 1, 1 + 2 + 3 + ... + n = n(n+1)/2.

**Preuve par induction sur n** :

**Cas de base (n = 1)** :
CÃ´tÃ© gauche : 1
CÃ´tÃ© droit : 1(1+1)/2 = 2/2 = 1
Les deux cÃ´tÃ©s sont Ã©gaux, donc P(1) est vrai. âœ“

**Ã‰tape d'induction** :
Soit k â‰¥ 1 un entier quelconque.

HypothÃ¨se d'induction : Supposons que P(k) soit vrai, c'est-Ã -dire :
1 + 2 + 3 + ... + k = k(k+1)/2

Nous voulons montrer que P(k+1) est vrai, c'est-Ã -dire :
1 + 2 + 3 + ... + k + (k+1) = (k+1)(k+2)/2

Partons du cÃ´tÃ© gauche de P(k+1) :
1 + 2 + 3 + ... + k + (k+1)
= [1 + 2 + 3 + ... + k] + (k+1)
= k(k+1)/2 + (k+1)           [par l'hypothÃ¨se d'induction]
= k(k+1)/2 + 2(k+1)/2        [mise au mÃªme dÃ©nominateur]
= [k(k+1) + 2(k+1)]/2
= [(k+1)(k + 2)]/2           [factorisation]
= (k+1)(k+2)/2

Nous avons montrÃ© que 1 + 2 + ... + (k+1) = (k+1)(k+2)/2.

Donc P(k+1) est vrai.

Par le principe d'induction mathÃ©matique, P(n) est vrai pour tout n â‰¥ 1. âˆ

**Analyse** : Cette preuve est un modÃ¨le parfait d'induction. Notez comment nous avons explicitement utilisÃ© l'hypothÃ¨se d'induction (la ligne oÃ¹ nous remplaÃ§ons 1+2+...+k par k(k+1)/2). Sans cette hypothÃ¨se, nous n'aurions pas pu progresser.

#### Exemple avec inÃ©galitÃ©s : 2â¿ > n

**ThÃ©orÃ¨me** : Pour tout entier n â‰¥ 1, 2â¿ > n.

**Preuve par induction sur n** :

**Cas de base (n = 1)** :
2Â¹ = 2 > 1 = n
Donc P(1) est vrai. âœ“

**Ã‰tape d'induction** :
Soit k â‰¥ 1 un entier quelconque.

HypothÃ¨se d'induction : Supposons que 2áµ > k.

Nous voulons montrer que 2áµâºÂ¹ > k+1.

Partons de 2áµâºÂ¹ :
2áµâºÂ¹ = 2 Â· 2áµ
      > 2 Â· k           [par l'hypothÃ¨se d'induction]
      = k + k

Maintenant, puisque k â‰¥ 1, nous avons k â‰¥ 1, donc :
k + k â‰¥ k + 1

Par transitivitÃ© :
2áµâºÂ¹ > k + k â‰¥ k + 1

Donc 2áµâºÂ¹ > k + 1.

Donc P(k+1) est vrai.

Par le principe d'induction mathÃ©matique, 2â¿ > n pour tout n â‰¥ 1. âˆ

**Point pÃ©dagogique** : Dans les preuves d'inÃ©galitÃ©s par induction, une technique courante est de sur-estimer ou sous-estimer stratÃ©giquement pour arriver au rÃ©sultat voulu. Ici, nous avons utilisÃ© k â‰¥ 1 pour obtenir k + k â‰¥ k + 1.

#### Exemple classique : Formule pour la somme gÃ©omÃ©trique

**ThÃ©orÃ¨me** : Pour tout entier n â‰¥ 0 et tout nombre rÃ©el r â‰  1, la somme gÃ©omÃ©trique vÃ©rifie :
1 + r + rÂ² + rÂ³ + ... + râ¿ = (râ¿âºÂ¹ - 1)/(r - 1)

**Preuve par induction sur n** :

**Cas de base (n = 0)** :
CÃ´tÃ© gauche : 1
CÃ´tÃ© droit : (râ°âºÂ¹ - 1)/(r - 1) = (r - 1)/(r - 1) = 1
Les deux cÃ´tÃ©s sont Ã©gaux, donc P(0) est vrai. âœ“

**Ã‰tape d'induction** :
Soit k â‰¥ 0 un entier quelconque.

HypothÃ¨se d'induction : Supposons que :
1 + r + rÂ² + ... + ráµ = (ráµâºÂ¹ - 1)/(r - 1)

Nous voulons montrer que :
1 + r + rÂ² + ... + ráµ + ráµâºÂ¹ = (ráµâºÂ² - 1)/(r - 1)

Partons du cÃ´tÃ© gauche :
1 + r + rÂ² + ... + ráµ + ráµâºÂ¹
= [1 + r + rÂ² + ... + ráµ] + ráµâºÂ¹
= (ráµâºÂ¹ - 1)/(r - 1) + ráµâºÂ¹     [hypothÃ¨se d'induction]
= (ráµâºÂ¹ - 1)/(r - 1) + ráµâºÂ¹(r - 1)/(r - 1)     [mÃªme dÃ©nominateur]
= [(ráµâºÂ¹ - 1) + ráµâºÂ¹(r - 1)]/(r - 1)
= [ráµâºÂ¹ - 1 + ráµâºÂ²- ráµâºÂ¹]/(r - 1)
= [ráµâºÂ² - 1]/(r - 1)
= (ráµâºÂ² - 1)/(r - 1)

Donc P(k+1) est vrai.

Par le principe d'induction mathÃ©matique, la formule est vraie pour tout n â‰¥ 0. âˆ

**Application pratique** : Cette formule est fondamentale en analyse d'algorithmes. Elle apparaÃ®t dans le calcul de la complexitÃ© de nombreux algorithmes, notamment ceux qui divisent le problÃ¨me par un facteur constant Ã  chaque Ã©tape (diviser pour rÃ©gner).

---

### ğŸ” 5. Induction forte (principe d'induction complÃ¨te)

Parfois, dans l'Ã©tape d'induction, nous avons besoin de supposer que P est vrai non seulement pour k, mais pour tous les entiers entre nâ‚€ et k. C'est le **principe d'induction forte** (ou **induction complÃ¨te**).

#### Formulation du principe d'induction forte

Pour prouver qu'une propriÃ©tÃ© P(n) est vraie pour tout n â‰¥ nâ‚€ :

**Cas de base** : Prouver P(nâ‚€) [et Ã©ventuellement P(nâ‚€+1), P(nâ‚€+2), ... selon les besoins].

**Ã‰tape d'induction forte** : Prouver que pour tout k â‰¥ nâ‚€, si P(nâ‚€), P(nâ‚€+1), ..., P(k) sont tous vrais, alors P(k+1) est vrai.

La diffÃ©rence avec l'induction simple est subtile mais importante. Dans l'induction simple, nous supposons seulement P(k). Dans l'induction forte, nous supposons P(i) pour tout i tel que nâ‚€ â‰¤ i â‰¤ k.

#### Pourquoi "induction forte" n'est pas plus forte logiquement

MalgrÃ© son nom, l'induction forte n'est pas logiquement plus puissante que l'induction simple. Tout ce qui peut Ãªtre prouvÃ© par induction forte peut aussi Ãªtre prouvÃ© par induction simple (bien que la preuve puisse Ãªtre plus laborieuse). Cependant, dans certains contextes, l'induction forte rend la preuve beaucoup plus naturelle et directe.

Pensez-y ainsi : dans l'induction simple, vous avez accÃ¨s au rÃ©sultat prÃ©cÃ©dent immÃ©diat. Dans l'induction forte, vous avez accÃ¨s Ã  tous les rÃ©sultats prÃ©cÃ©dents. C'est comme avoir plus d'outils dans votre boÃ®te Ã  outils, mÃªme si techniquement vous pourriez tout faire avec un seul outil (au prix de plus d'efforts).

#### Exemple : ReprÃ©sentation en sommes de puissances de 2

**ThÃ©orÃ¨me** : Tout entier positif n peut Ãªtre Ã©crit comme une somme de puissances distinctes de 2.

**Exemples** :
- 5 = 4 + 1 = 2Â² + 2â°
- 13 = 8 + 4 + 1 = 2Â³ + 2Â² + 2â°
- 100 = 64 + 32 + 4 = 2â¶ + 2âµ + 2Â²

**Preuve par induction forte sur n** :

**Cas de base (n = 1)** :
1 = 2â°, qui est une puissance de 2.
Donc P(1) est vrai. âœ“

**Ã‰tape d'induction forte** :
Soit k â‰¥ 1 un entier quelconque.

HypothÃ¨se d'induction forte : Supposons que pour tout i tel que 1 â‰¤ i â‰¤ k, i peut Ãªtre Ã©crit comme une somme de puissances distinctes de 2.

Nous voulons montrer que k+1 peut aussi Ãªtre Ã©crit comme une somme de puissances distinctes de 2.

**Cas 1** : k+1 est une puissance de 2.
Alors k+1 = 2áµ pour un certain m, et nous avons terminÃ©.

**Cas 2** : k+1 n'est pas une puissance de 2.
Alors il existe un entier m tel que 2áµ < k+1 < 2áµâºÂ¹.

Posons r = (k+1) - 2áµ.

Nous avons :
- r = (k+1) - 2áµ > (k+1) - (k+1) = 0 (donc r > 0)
- r = (k+1) - 2áµ < 2áµâºÂ¹ - 2áµ = 2áµ (donc r < 2áµ)

En particulier, r â‰¤ 2áµ - 1 < 2áµ < k+1, donc r â‰¤ k.

Par l'hypothÃ¨se d'induction forte appliquÃ©e Ã  r (puisque 1 â‰¤ r â‰¤ k), r peut Ãªtre Ã©crit comme une somme de puissances distinctes de 2. Soit r = 2^{iâ‚} + 2^{iâ‚‚} + ... + 2^{iâ‚š} oÃ¹ les exposants sont distincts.

Alors :
k+1 = 2áµ + r = 2áµ + 2^{iâ‚} + 2^{iâ‚‚} + ... + 2^{iâ‚š}

Puisque r < 2áµ, tous les exposants iâ‚, iâ‚‚, ..., iâ‚š sont strictement infÃ©rieurs Ã  m (car la plus grande puissance de 2 dans r est au plus 2^{m-1}).

Donc tous les exposants dans cette somme (m, iâ‚, iâ‚‚, ..., iâ‚š) sont distincts.

Donc k+1 peut Ãªtre Ã©crit comme une somme de puissances distinctes de 2.

Par le principe d'induction forte, tout entier positif peut Ãªtre Ã©crit comme une somme de puissances distinctes de 2. âˆ

**Pourquoi l'induction forte Ã©tait nÃ©cessaire** : Dans l'Ã©tape d'induction, nous avons construit r qui n'Ã©tait pas nÃ©cessairement Ã©gal Ã  k. Nous avions seulement r â‰¤ k. Pour appliquer l'hypothÃ¨se d'induction Ã  r, nous avions besoin de supposer que la propriÃ©tÃ© est vraie pour tous les entiers de 1 Ã  k, pas seulement pour k. C'est prÃ©cisÃ©ment ce que permet l'induction forte.

#### Exemple : ThÃ©orÃ¨me fondamental de l'arithmÃ©tique (version faible)

**ThÃ©orÃ¨me** : Tout entier n â‰¥ 2 est soit premier, soit produit de nombres premiers.

**Preuve par induction forte sur n** :

**Cas de base (n = 2)** :
2 est premier.
Donc P(2) est vrai. âœ“

**Ã‰tape d'induction forte** :
Soit k â‰¥ 2 un entier quelconque.

HypothÃ¨se d'induction forte : Supposons que pour tout i tel que 2 â‰¤ i â‰¤ k, i est soit premier, soit produit de nombres premiers.

Nous voulons montrer que k+1 est soit premier, soit produit de nombres premiers.

**Cas 1** : k+1 est premier.
Alors nous avons terminÃ©.

**Cas 2** : k+1 n'est pas premier.
Par dÃ©finition, cela signifie que k+1 a un diviseur propre, c'est-Ã -dire qu'il existe des entiers a et b tels que :
- k+1 = a Ã— b
- 1 < a < k+1
- 1 < b < k+1

Puisque a et b sont strictement entre 1 et k+1, nous avons 2 â‰¤ a â‰¤ k et 2 â‰¤ b â‰¤ k.

Par l'hypothÃ¨se d'induction forte appliquÃ©e Ã  a :
- Soit a est premier
- Soit a est un produit de nombres premiers : a = pâ‚ Ã— pâ‚‚ Ã— ... Ã— páµ£

De mÃªme, par l'hypothÃ¨se d'induction forte appliquÃ©e Ã  b :
- Soit b est premier
- Soit b est un produit de nombres premiers : b = qâ‚ Ã— qâ‚‚ Ã— ... Ã— qâ‚›

Dans tous les cas, k+1 = a Ã— b est un produit de nombres premiers (les facteurs premiers de a et de b).

Donc P(k+1) est vrai.

Par le principe d'induction forte, tout entier n â‰¥ 2 est soit premier, soit produit de nombres premiers. âˆ

**Note** : Le thÃ©orÃ¨me fondamental de l'arithmÃ©tique affirme en fait quelque chose de plus fort : non seulement tout entier peut Ãªtre factorisÃ© en nombres premiers, mais cette factorisation est unique (Ã  l'ordre prÃ¨s). La preuve de l'unicitÃ© nÃ©cessite des techniques supplÃ©mentaires que nous verrons dans des leÃ§ons futures.

---

### ğŸ’» 6. Induction et algorithmes rÃ©cursifs

L'induction mathÃ©matique est l'outil naturel pour prouver la correction d'algorithmes rÃ©cursifs. La structure d'une fonction rÃ©cursive correspond exactement Ã  la structure d'une preuve par induction.

#### Correspondance entre rÃ©cursivitÃ© et induction

ConsidÃ©rez une fonction rÃ©cursive qui calcule quelque chose sur un entier n :

```javascript
function f(n) {
  if (n === baseCas) {
    return valeurDeBase;
  } else {
    return combinerAvec(f(n - 1));  // ou f(quelquechoseDePlusPetit)
  }
}
```

Pour prouver que cette fonction est correcte par induction :

**Cas de base de l'induction** â†” **Cas de base de la rÃ©cursion** : Vous prouvez que `f(baseCas)` retourne la bonne valeur.

**Ã‰tape d'induction** â†” **Ã‰tape rÃ©cursive** : Vous supposez que `f(k)` est correct (hypothÃ¨se d'induction), et vous prouvez que `f(k+1)` est correct en utilisant le fait que `f(k+1)` est calculÃ© Ã  partir de `f(k)`.

#### Exemple dÃ©taillÃ© : Factorielle

**SpÃ©cification** : La fonction `factorial(n)` doit retourner n! = n Ã— (n-1) Ã— ... Ã— 2 Ã— 1 pour tout n â‰¥ 0, avec 0! = 1 par convention.

**ImplÃ©mentation rÃ©cursive** :

```javascript
function factorial(n) {
  // PrÃ©condition : n est un entier non-nÃ©gatif
  
  if (n === 0) {
    return 1;  // 0! = 1 par dÃ©finition
  } else {
    return n * factorial(n - 1);
  }
}
```

**ThÃ©orÃ¨me de correction** : Pour tout entier n â‰¥ 0, `factorial(n)` retourne n!.

**Preuve par induction sur n** :

**Cas de base (n = 0)** :
`factorial(0)` retourne 1 (ligne 2).
Par dÃ©finition, 0! = 1.
Donc `factorial(0)` retourne bien 0!. âœ“

**Ã‰tape d'induction** :
Soit k â‰¥ 0 un entier quelconque.

HypothÃ¨se d'induction : Supposons que `factorial(k)` retourne k!.

Nous voulons montrer que `factorial(k+1)` retourne (k+1)!.

Analysons l'exÃ©cution de `factorial(k+1)` :
- Puisque k+1 > 0, nous entrons dans le else (ligne 5).
- `factorial(k+1)` retourne `(k+1) * factorial(k)`.
- Par l'hypothÃ¨se d'induction, `factorial(k)` retourne k!.
- Donc `factorial(k+1)` retourne `(k+1) * k!`.
- Par dÃ©finition, (k+1)! = (k+1) Ã— k!.
- Donc `factorial(k+1)` retourne (k+1)!. âœ“

Par le principe d'induction mathÃ©matique, `factorial(n)` retourne n! pour tout n â‰¥ 0. âˆ

**Observation importante** : L'hypothÃ¨se d'induction ("Supposons que `factorial(k)` retourne k!") correspond exactement Ã  l'hypothÃ¨se que l'appel rÃ©cursif `factorial(n-1)` est correct. C'est pourquoi l'induction est si naturelle pour prouver la correction des fonctions rÃ©cursives.

#### Exemple avec induction forte : Suite de Fibonacci

**SpÃ©cification** : La suite de Fibonacci est dÃ©finie par :
- F(0) = 0
- F(1) = 1
- F(n) = F(n-1) + F(n-2) pour n â‰¥ 2

**ImplÃ©mentation rÃ©cursive** :

```javascript
function fibonacci(n) {
  // PrÃ©condition : n est un entier non-nÃ©gatif
  
  if (n === 0) {
    return 0;
  } else if (n === 1) {
    return 1;
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}
```

**ThÃ©orÃ¨me de correction** : Pour tout entier n â‰¥ 0, `fibonacci(n)` retourne F(n).

**Preuve par induction forte sur n** :

**Cas de base (n = 0)** :
`fibonacci(0)` retourne 0.
Par dÃ©finition, F(0) = 0.
Donc correct. âœ“

**Cas de base (n = 1)** :
`fibonacci(1)` retourne 1.
Par dÃ©finition, F(1) = 1.
Donc correct. âœ“

**Ã‰tape d'induction forte** :
Soit k â‰¥ 1 un entier quelconque.

HypothÃ¨se d'induction forte : Supposons que pour tout i tel que 0 â‰¤ i â‰¤ k, `fibonacci(i)` retourne F(i).

Nous voulons montrer que `fibonacci(k+1)` retourne F(k+1).

Puisque k+1 â‰¥ 2, l'exÃ©cution de `fibonacci(k+1)` entre dans le else (ligne 7) et retourne :
`fibonacci(k) + fibonacci(k-1)`

Par l'hypothÃ¨se d'induction forte :
- `fibonacci(k)` retourne F(k) (car 0 â‰¤ k â‰¤ k)
- `fibonacci(k-1)` retourne F(k-1) (car 0 â‰¤ k-1 â‰¤ k)

Donc `fibonacci(k+1)` retourne F(k) + F(k-1).

Par la dÃ©finition rÃ©cursive de la suite de Fibonacci :
F(k+1) = F(k) + F(k-1)

Donc `fibonacci(k+1)` retourne F(k+1). âœ“

Par le principe d'induction forte, `fibonacci(n)` retourne F(n) pour tout n â‰¥ 0. âˆ

**Pourquoi l'induction forte** : Notez que dans l'Ã©tape rÃ©cursive, nous faisons deux appels : `fibonacci(n-1)` et `fibonacci(n-2)`. Pour prouver la correction, nous avons besoin de supposer que les deux appels sont corrects. L'induction simple ne suffirait pas car elle ne nous donnerait que la correction de `fibonacci(k)`, pas de `fibonacci(k-1)`. L'induction forte nous donne la correction pour tous les cas prÃ©cÃ©dents, ce qui correspond aux multiples appels rÃ©cursifs.

---

### âš ï¸ 7. PiÃ¨ges et erreurs communes dans les preuves par induction

L'induction est une technique puissante, mais elle est aussi source de nombreuses erreurs subtiles. Apprenons Ã  les reconnaÃ®tre.

#### Erreur 1 : Oublier le cas de base

**Exemple de "preuve" erronÃ©e** :

"ThÃ©orÃ¨me" : Tous les chevaux sont de la mÃªme couleur.

"Preuve" par induction sur le nombre de chevaux :

Ã‰tape d'induction : Supposons que dans tout ensemble de k chevaux, tous les chevaux sont de la mÃªme couleur.

ConsidÃ©rons un ensemble de k+1 chevaux. NumÃ©rotons-les : Hâ‚, Hâ‚‚, ..., Hâ‚–, Hâ‚–â‚Šâ‚.

ConsidÃ©rons le sous-ensemble {Hâ‚, Hâ‚‚, ..., Hâ‚–}. Par l'hypothÃ¨se d'induction, ces k chevaux sont tous de la mÃªme couleur.

ConsidÃ©rons le sous-ensemble {Hâ‚‚, Hâ‚ƒ, ..., Hâ‚–â‚Šâ‚}. Par l'hypothÃ¨se d'induction, ces k chevaux sont tous de la mÃªme couleur.

Puisque Hâ‚‚, Hâ‚ƒ, ..., Hâ‚– apparaissent dans les deux ensembles, tous les chevaux de {Hâ‚, Hâ‚‚, ..., Hâ‚–} ont la mÃªme couleur que tous les chevaux de {Hâ‚‚, Hâ‚ƒ, ..., Hâ‚–â‚Šâ‚}.

Donc tous les k+1 chevaux sont de la mÃªme couleur. âˆ

**OÃ¹ est l'erreur ?** Le cas de base est absent ! Si on essaie de le vÃ©rifier :

Pour k = 1 : Un ensemble d'un seul cheval ? Oui, il est de sa propre couleur. âœ“

Pour k = 2 : Ah ! Le raisonnement de l'Ã©tape d'induction ne fonctionne pas. Si nous avons deux chevaux Hâ‚ et Hâ‚‚, les deux sous-ensembles sont {Hâ‚} et {Hâ‚‚}, et ils ne partagent aucun cheval en commun. Nous ne pouvons pas conclure qu'ils ont la mÃªme couleur.

L'Ã©tape d'induction ne fonctionne que pour k â‰¥ 2, mais elle Ã©choue prÃ©cisÃ©ment au moment critique de passer de k=1 Ã  k=2.

**LeÃ§on** : Le cas de base n'est pas une formalitÃ©. Il est essentiel. Sans lui, l'effet domino ne dÃ©marre jamais.

#### Erreur 2 : HypothÃ¨se d'induction mal formulÃ©e ou utilisÃ©e de maniÃ¨re circulaire

**Exemple de "preuve" erronÃ©e** :

"ThÃ©orÃ¨me" : Pour tout n â‰¥ 1, n = n + 1.

"Preuve" par induction :

Cas de base : Pour n = 1, nous avons... [On ne peut mÃªme pas vÃ©rifier le cas de base car 1 â‰  2.]

Mais supposons qu'on ignore ce dÃ©tail et qu'on continue :

Ã‰tape d'induction : Supposons que k = k + 1.
Nous voulons montrer que k + 1 = k + 2.
Ajoutons 1 aux deux cÃ´tÃ©s de l'hypothÃ¨se d'induction :
k + 1 = (k + 1) + 1 = k + 2. âœ“

**OÃ¹ est l'erreur ?** Cette "preuve" est absurde car :
1. Le cas de base est faux (1 â‰  2).
2. L'hypothÃ¨se d'induction elle-mÃªme est une affirmation fausse (k â‰  k+1).

Mais cela illustre un danger : si vous partez d'une hypothÃ¨se fausse, vous pouvez "prouver" n'importe quoi par manipulation algÃ©brique. L'induction ne peut prouver quelque chose de vrai que si le cas de base est vrai et que l'Ã©tape d'induction est valide.

#### Erreur 3 : Utiliser ce qu'on veut prouver dans l'Ã©tape d'induction (raisonnement circulaire)

**Exemple d'erreur subtile** :

ThÃ©orÃ¨me : Pour tout n â‰¥ 1, 1 + 2 + ... + n = n(n+1)/2.

"Preuve" erronÃ©e :

HypothÃ¨se d'induction : Supposons que 1 + 2 + ... + k = k(k+1)/2.

Nous voulons montrer que 1 + 2 + ... + k + (k+1) = (k+1)(k+2)/2.

"Puisque c'est une formule bien connue et vraie pour k+1, elle est vraie." âœ—

**OÃ¹ est l'erreur ?** Vous ne pouvez pas simplement affirmer que P(k+1) est vrai parce que "c'est connu". Vous devez le dÃ©duire de P(k). Le but de l'induction est prÃ©cisÃ©ment de prouver que la formule est vraie pour tous les n, pas de supposer qu'elle l'est.

#### Erreur 4 : GÃ©nÃ©ralisation incorrecte du cas de base

**Exemple** : Prouver que nÂ² < 2â¿ pour tout n â‰¥ 5.

"Preuve" erronÃ©e :

Cas de base : n = 0 : 0Â² = 0 < 1 = 2â°. âœ“

[L'Ã©tape d'induction suit correctement...]

**OÃ¹ est l'erreur ?** Le thÃ©orÃ¨me dit "pour tout n â‰¥ 5", mais le cas de base vÃ©rifie n = 0. Nous avons vÃ©rifiÃ© le mauvais cas de base ! Il faut vÃ©rifier n = 5 :

5Â² = 25 < 32 = 2âµ. âœ“

De plus, si vous utilisez l'induction pour passer de k Ã  k+1, vous devez vous assurer que tous les entiers de 5 Ã  l'infini sont couverts, pas de 0 Ã  l'infini.

#### Erreur 5 : Confusion entre induction et exemple

**Non-preuve** :

"ThÃ©orÃ¨me" : Pour tout n, nÂ² + n + 41 est premier.

"VÃ©rification" :
- n = 0 : 0Â² + 0 + 41 = 41, premier âœ“
- n = 1 : 1Â² + 1 + 41 = 43, premier âœ“
- n = 2 : 2Â² + 2 + 41 = 47, premier âœ“
- n = 3 : 3Â² + 3 + 41 = 53, premier âœ“
- ...

"Donc c'est vrai pour tout n." âœ—

**OÃ¹ est l'erreur ?** Ce n'est pas une preuve par induction. C'est juste une vÃ©rification d'exemples. Une preuve par induction nÃ©cessite de montrer que si P(k) est vrai, alors P(k+1) est vrai. De plus, ce "thÃ©orÃ¨me" est en fait faux : pour n = 40, nous avons 40Â² + 40 + 41 = 1681 = 41Â², qui n'est pas premier.

---

## ğŸ’¡ Exemple travaillÃ© dÃ©taillÃ©

### ScÃ©nario : Analyse de complexitÃ© et correction d'un algorithme de tri rÃ©cursif

Vous implÃ©mentez un algorithme de tri par fusion (merge sort) pour votre application web. Vous voulez non seulement que l'algorithme fonctionne, mais aussi prouver formellement qu'il est correct et analyser sa complexitÃ©.

#### Contexte : L'algorithme de tri par fusion

Le tri par fusion est un algorithme de tri classique qui utilise la stratÃ©gie "diviser pour rÃ©gner" :

1. **Diviser** : Diviser le tableau en deux moitiÃ©s Ã  peu prÃ¨s Ã©gales
2. **RÃ©gner** : Trier rÃ©cursivement chaque moitiÃ©
3. **Combiner** : Fusionner les deux moitiÃ©s triÃ©es en un seul tableau triÃ©

#### ImplÃ©mentation en JavaScript

```javascript
/**
 * Fusionne deux tableaux triÃ©s en un seul tableau triÃ©
 * 
 * PrÃ©conditions :
 *   - left est un tableau triÃ© en ordre croissant
 *   - right est un tableau triÃ© en ordre croissant
 * 
 * Postconditions :
 *   - Retourne un tableau contenant tous les Ã©lÃ©ments de left et right
 *   - Le tableau retournÃ© est triÃ© en ordre croissant
 */
function merge(left, right) {
  const result = [];
  let i = 0;  // Index pour left
  let j = 0;  // Index pour right
  
  // Tant qu'il reste des Ã©lÃ©ments dans les deux tableaux
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }
  
  // Ajouter les Ã©lÃ©ments restants de left (s'il y en a)
  while (i < left.length) {
    result.push(left[i]);
    i++;
  }
  
  // Ajouter les Ã©lÃ©ments restants de right (s'il y en a)
  while (j < right.length) {
    result.push(right[j]);
    j++;
  }
  
  return result;
}

/**
 * Trie un tableau en utilisant l'algorithme de tri par fusion
 * 
 * PrÃ©conditions :
 *   - array est un tableau d'Ã©lÃ©ments comparables
 * 
 * Postconditions :
 *   - Retourne un nouveau tableau contenant tous les Ã©lÃ©ments de array
 *   - Le tableau retournÃ© est triÃ© en ordre croissant
 */
function mergeSort(array) {
  // Cas de base : un tableau de 0 ou 1 Ã©lÃ©ment est dÃ©jÃ  triÃ©
  if (array.length <= 1) {
    return array;
  }
  
  // Diviser le tableau en deux moitiÃ©s
  const mid = Math.floor(array.length / 2);
  const left = array.slice(0, mid);
  const right = array.slice(mid);
  
  // Trier rÃ©cursivement chaque moitiÃ©
  const sortedLeft = mergeSort(left);
  const sortedRight = mergeSort(right);
  
  // Fusionner les deux moitiÃ©s triÃ©es
  return merge(sortedLeft, sortedRight);
}
```

#### ThÃ©orÃ¨me 1 : Correction de la fonction merge

**Ã‰noncÃ©** : Si `left` et `right` sont des tableaux triÃ©s en ordre croissant, alors `merge(left, right)` retourne un tableau triÃ© en ordre croissant contenant exactement les Ã©lÃ©ments de `left` et `right`.

**Preuve** :

Nous allons prouver trois propriÃ©tÃ©s :

**PropriÃ©tÃ© 1** : Le tableau retournÃ© contient exactement les Ã©lÃ©ments de `left` et `right`.

Ã€ chaque itÃ©ration de la premiÃ¨re boucle while, nous ajoutons soit un Ã©lÃ©ment de `left`, soit un Ã©lÃ©ment de `right` Ã  `result`, et nous incrÃ©mentons l'index correspondant. AprÃ¨s la premiÃ¨re boucle, tous les Ã©lÃ©ments jusqu'Ã  l'index `i` de `left` et tous les Ã©lÃ©ments jusqu'Ã  l'index `j` de `right` ont Ã©tÃ© ajoutÃ©s Ã  `result`.

Les deux boucles suivantes ajoutent tous les Ã©lÃ©ments restants. Ã€ la fin, `i = left.length` et `j = right.length`, donc tous les Ã©lÃ©ments ont Ã©tÃ© ajoutÃ©s.

Aucun Ã©lÃ©ment n'est ajoutÃ© deux fois (chaque Ã©lÃ©ment est ajoutÃ© quand son index est incrÃ©mentÃ©, et les index sont strictement croissants).

Donc `result` contient exactement les Ã©lÃ©ments de `left` et `right`. âœ“

**PropriÃ©tÃ© 2** : Le tableau retournÃ© est triÃ© en ordre croissant.

**Invariant de la premiÃ¨re boucle while** : AprÃ¨s chaque itÃ©ration, `result` contient les Ã©lÃ©ments dÃ©jÃ  traitÃ©s de `left` et `right` dans l'ordre croissant, et si `result` n'est pas vide, alors `result[result.length - 1] â‰¤ left[i]` (si `i < left.length`) et `result[result.length - 1] â‰¤ right[j]` (si `j < right.length`).

**Initialisation** : Avant la premiÃ¨re itÃ©ration, `result` est vide, donc l'invariant est trivialement vrai.

**PrÃ©servation** : Supposons que l'invariant soit vrai au dÃ©but d'une itÃ©ration.
- Si `left[i] â‰¤ right[j]`, nous ajoutons `left[i]` Ã  `result`.
- Par l'invariant, si `result` n'Ã©tait pas vide, `result[result.length - 1] â‰¤ left[i]` (donc l'ordre est prÃ©servÃ©).
- Puisque `left` est triÃ©, `left[i] â‰¤ left[i+1]`.
- Puisque `left[i] â‰¤ right[j]` (condition du if), l'Ã©lÃ©ment ajoutÃ© est â‰¤ au prochain Ã©lÃ©ment potentiel.
- L'invariant est prÃ©servÃ©. Le cas symÃ©trique (right[j] < left[i]) est similaire.

**Terminaison de la premiÃ¨re boucle** : Quand la premiÃ¨re boucle se termine, au moins un des deux tableaux a Ã©tÃ© entiÃ¨rement parcouru. Les Ã©lÃ©ments restants de l'autre tableau sont tous â‰¥ au dernier Ã©lÃ©ment de `result` (par l'invariant).

**DeuxiÃ¨me et troisiÃ¨me boucles** : Puisque `left` et `right` sont triÃ©s, ajouter les Ã©lÃ©ments restants d'un tableau dÃ©jÃ  triÃ© prÃ©serve l'ordre.

Donc `result` est triÃ©. âœ“

La fonction `merge` est correcte. âˆ

#### ThÃ©orÃ¨me 2 : Correction de mergeSort par induction forte

**Ã‰noncÃ©** : Pour tout tableau `array`, `mergeSort(array)` retourne un tableau triÃ© contenant exactement les Ã©lÃ©ments de `array`.

**Preuve par induction forte sur n = array.length** :

**Cas de base (n = 0 ou n = 1)** :
Si `array.length â‰¤ 1`, la fonction retourne immÃ©diatement `array` (ligne 4).
Un tableau vide ou Ã  un seul Ã©lÃ©ment est trivialement triÃ©.
Donc P(0) et P(1) sont vrais. âœ“

**Ã‰tape d'induction forte** :
Soit k â‰¥ 1 un entier quelconque.

HypothÃ¨se d'induction forte : Pour tout i tel que 0 â‰¤ i â‰¤ k, `mergeSort` appliquÃ© Ã  un tableau de longueur i retourne un tableau triÃ© contenant exactement les Ã©lÃ©ments du tableau d'entrÃ©e.

ConsidÃ©rons un tableau `array` de longueur k+1.

Puisque k+1 â‰¥ 2, nous n'entrons pas dans le cas de base.

L'algorithme calcule :
- `mid = Math.floor((k+1)/2)`
- `left = array.slice(0, mid)` de longueur `mid`
- `right = array.slice(mid)` de longueur `(k+1) - mid`

Puisque `mid â‰¥ 1` et `mid â‰¤ k`, nous avons `1 â‰¤ mid â‰¤ k`.
De mÃªme, `(k+1) - mid â‰¥ 1` et `(k+1) - mid â‰¤ k`.

Par l'hypothÃ¨se d'induction forte :
- `mergeSort(left)` retourne `sortedLeft`, un tableau triÃ© de longueur `mid` contenant exactement les Ã©lÃ©ments de `left`.
- `mergeSort(right)` retourne `sortedRight`, un tableau triÃ© de longueur `(k+1) - mid` contenant exactement les Ã©lÃ©ments de `right`.

Puisque `left` et `right` partitionnent `array`, les Ã©lÃ©ments de `left` et `right` sont exactement les Ã©lÃ©ments de `array`.

Par le ThÃ©orÃ¨me 1 (correction de merge), `merge(sortedLeft, sortedRight)` retourne un tableau triÃ© contenant exactement les Ã©lÃ©ments de `sortedLeft` et `sortedRight`, donc exactement les Ã©lÃ©ments de `array`.

Donc `mergeSort(array)` retourne un tableau triÃ© contenant exactement les Ã©lÃ©ments de `array`.

Par le principe d'induction forte, `mergeSort` est correct pour tout tableau. âˆ

**Observation** : Notez la correspondance parfaite entre la structure rÃ©cursive de l'algorithme et la structure de la preuve par induction. C'est un exemple typique de comment l'induction est l'outil naturel pour prouver la correction d'algorithmes rÃ©cursifs.

#### ThÃ©orÃ¨me 3 : ComplexitÃ© temporelle de mergeSort

**Ã‰noncÃ©** : La complexitÃ© temporelle de `mergeSort` sur un tableau de taille n est O(n log n).

**Analyse** :

Soit T(n) le nombre d'opÃ©rations effectuÃ©es par `mergeSort` sur un tableau de taille n.

**Cas de base** : Si n â‰¤ 1, T(n) = O(1) (retour immÃ©diat).

**Cas rÃ©cursif** : Si n > 1 :
- Diviser le tableau : O(n) (slice crÃ©e des copies)
- Deux appels rÃ©cursifs : T(âŒŠn/2âŒ‹) + T(âŒˆn/2âŒ‰)
- Fusion : O(n) (merge parcourt tous les Ã©lÃ©ments une fois)

Donc : T(n) = 2T(n/2) + O(n) pour n > 1

C'est une relation de rÃ©currence classique. Pour la rÃ©soudre, nous pouvons utiliser le **thÃ©orÃ¨me Master** (que nous verrons dans une leÃ§on future) ou prouver directement par induction que T(n) = O(n log n).

**Preuve que T(n) â‰¤ cn log n pour un certain c > 0** (par induction forte sur n) :

**Cas de base** : Pour n = 1, T(1) = câ‚ pour une certaine constante câ‚. Choisissons c â‰¥ câ‚. Alors T(1) â‰¤ c Â· 1 Â· log 1 = 0 n'est pas vrai...

[Correction : pour les petites valeurs de n, l'inÃ©galitÃ© n'est pas valide. Nous devons commencer l'induction Ã  une valeur suffisamment grande, disons nâ‚€ = 2.]

**Cas de base (n = 2)** :
T(2) = 2T(1) + câ‚‚ Â· 2 pour une certaine constante câ‚‚.
     = 2câ‚ + 2câ‚‚

Nous voulons T(2) â‰¤ c Â· 2 Â· log 2 = 2c.
Donc nous avons besoin de 2câ‚ + 2câ‚‚ â‰¤ 2c.
Choisissons c â‰¥ câ‚ + câ‚‚. Alors l'inÃ©galitÃ© est satisfaite. âœ“

**Ã‰tape d'induction forte** :
Soit k â‰¥ 2 un entier quelconque.

HypothÃ¨se d'induction : Pour tout i tel que 2 â‰¤ i â‰¤ k, T(i) â‰¤ ci log i.

ConsidÃ©rons T(k+1) pour k+1 > 2.

Par la rÃ©currence :
T(k+1) = 2T(âŒŠ(k+1)/2âŒ‹) + câ‚‚(k+1)

Puisque âŒŠ(k+1)/2âŒ‹ â‰¤ k (pour k â‰¥ 1), nous pouvons appliquer l'hypothÃ¨se d'induction :

T(âŒŠ(k+1)/2âŒ‹) â‰¤ câŒŠ(k+1)/2âŒ‹ log âŒŠ(k+1)/2âŒ‹

Pour simplifier, supposons que k+1 est une puissance de 2, disons k+1 = 2áµ. Alors :

T(2áµ) = 2T(2^{m-1}) + câ‚‚ Â· 2áµ
      â‰¤ 2(c Â· 2^{m-1} Â· (m-1)) + câ‚‚ Â· 2áµ   [hypothÃ¨se d'induction]
      = c Â· 2áµ Â· (m-1) + câ‚‚ Â· 2áµ
      = 2áµ[c(m-1) + câ‚‚]
      = 2áµ[cm - c + câ‚‚]

Nous voulons montrer que cela est â‰¤ c Â· 2áµ Â· m = 2áµ Â· cm.

Donc nous avons besoin de : cm - c + câ‚‚ â‰¤ cm
C'est-Ã -dire : câ‚‚ â‰¤ c

Puisque nous avons choisi c â‰¥ câ‚ + câ‚‚, cette inÃ©galitÃ© est satisfaite.

Donc T(2áµ) â‰¤ c Â· 2áµ Â· m = c Â· 2áµ Â· log 2áµ. âœ“

[Pour les valeurs de n qui ne sont pas des puissances de 2, un argument similaire mais plus technique s'applique.]

Par induction, T(n) = O(n log n). âˆ

**Note** : Cette analyse montre la puissance de l'induction pour prouver des rÃ©sultats sur la complexitÃ©. Les relations de rÃ©currence sont naturellement analysÃ©es par induction puisqu'elles ont exactement la structure d'une dÃ©finition rÃ©cursive.

#### Application SQL : Garantie d'intÃ©gritÃ© rÃ©fÃ©rentielle avec triggers

Maintenant, implÃ©mentons une fonctionnalitÃ© qui utilise ces rÃ©sultats pour garantir que les donnÃ©es dans PostgreSQL restent cohÃ©rentes.

```sql
-- Table pour stocker des logs de tri
CREATE TABLE sort_logs (
    id SERIAL PRIMARY KEY,
    input_size INTEGER NOT NULL,
    sorted_array JSONB NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT size_matches_array CHECK (
        input_size = jsonb_array_length(sorted_array)
    )
);

-- Fonction de validation : vÃ©rifie qu'un tableau JSON est triÃ©
CREATE OR REPLACE FUNCTION is_sorted(arr JSONB)
RETURNS BOOLEAN AS $$
DECLARE
    i INTEGER;
    len INTEGER;
BEGIN
    len := jsonb_array_length(arr);
    
    -- Un tableau vide ou Ã  un Ã©lÃ©ment est triÃ©
    IF len <= 1 THEN
        RETURN TRUE;
    END IF;
    
    -- VÃ©rifier que chaque Ã©lÃ©ment est â‰¤ au suivant
    FOR i IN 0..(len-2) LOOP
        IF (arr->i)::numeric > (arr->(i+1))::numeric THEN
            RETURN FALSE;
        END IF;
    END LOOP;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Trigger pour garantir que seuls des tableaux triÃ©s sont insÃ©rÃ©s
CREATE OR REPLACE FUNCTION check_sorted_array()
RETURNS TRIGGER AS $$
BEGIN
    IF NOT is_sorted(NEW.sorted_array) THEN
        RAISE EXCEPTION 'Array is not sorted: %', NEW.sorted_array;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_sort_log_insert
BEFORE INSERT ON sort_logs
FOR EACH ROW
EXECUTE FUNCTION check_sorted_array();
```

**ThÃ©orÃ¨me 4** : PropriÃ©tÃ© invariante de la base de donnÃ©es

**Ã‰noncÃ©** : Avec le trigger `before_sort_log_insert`, il est impossible d'insÃ©rer dans `sort_logs` un tableau qui n'est pas triÃ©.

**Preuve** :

Le trigger `before_sort_log_insert` est exÃ©cutÃ© BEFORE INSERT, ce qui signifie qu'il s'exÃ©cute avant que la ligne soit rÃ©ellement insÃ©rÃ©e dans la table.

La fonction `check_sorted_array()` appelle `is_sorted(NEW.sorted_array)`.

Si `is_sorted` retourne FALSE, la fonction `check_sorted_array` lÃ¨ve une exception via RAISE EXCEPTION.

Quand une exception est levÃ©e dans un trigger BEFORE INSERT, PostgreSQL annule l'insertion (rollback).

Donc, une insertion ne rÃ©ussit que si `is_sorted` retourne TRUE.

La fonction `is_sorted` retourne TRUE si et seulement si le tableau satisfait la propriÃ©tÃ© : pour tout i, arr[i] â‰¤ arr[i+1].

Cela correspond exactement Ã  la dÃ©finition d'un tableau triÃ©.

Donc, une insertion ne rÃ©ussit que si le tableau est triÃ©.

Par consÃ©quent, il est impossible d'insÃ©rer un tableau non triÃ© dans `sort_logs`. âˆ

**Observation** : Ce thÃ©orÃ¨me Ã©tablit un invariant de base de donnÃ©es : une propriÃ©tÃ© qui est toujours vraie dans la base. Les invariants sont cruciaux pour la fiabilitÃ© des systÃ¨mes. Ils sont prouvÃ©s en analysant tous les chemins qui pourraient modifier la base (ici, les insertions) et en montrant que tous prÃ©servent la propriÃ©tÃ©.

---

## ğŸ¯ Exercices appliquÃ©s

### Exercice 1 : Niveau Facile - Preuves par contradiction

**Ã‰noncÃ©** : Prouvez les Ã©noncÃ©s suivants en utilisant une preuve par contradiction.

**a)** Il n'existe pas de plus petit nombre rÃ©el positif.

**b)** Pour tous entiers a et b, si ab est impair, alors a et b sont tous les deux impairs.

**c)** âˆš3 est irrationnel. (Suivez la structure de la preuve de l'irrationnalitÃ© de âˆš2.)

**CritÃ¨res d'Ã©valuation** :
- HypothÃ¨se par l'absurde clairement Ã©noncÃ©e (1 point par preuve)
- DÃ©roulement logique correct (2 points par preuve)
- Contradiction identifiÃ©e correctement (1 point par preuve)

**Indice** : Pour (a), supposez qu'un tel nombre existe et appelez-le r. Que pouvez-vous dire de r/2 ? Pour (b), vous avez dÃ©jÃ  vu une preuve de ce rÃ©sultat par contraposÃ©e dans la leÃ§on M1.C1.L3 ; essayez maintenant par contradiction. Pour (c), la preuve est trÃ¨s similaire Ã  celle de âˆš2 : supposez que âˆš3 = p/q sous forme rÃ©duite, Ã©levez au carrÃ©, et montrez que p et q ont tous deux un facteur commun de 3.

**Solution complÃ¨te pour (a)** :

**ThÃ©orÃ¨me** : Il n'existe pas de plus petit nombre rÃ©el positif.

**Preuve par contradiction** :

Supposons, pour obtenir une contradiction, qu'il existe un plus petit nombre rÃ©el positif.

Appelons ce nombre r. Par hypothÃ¨se :
- r > 0 (r est positif)
- Pour tout nombre rÃ©el x > 0, nous avons r â‰¤ x (r est le plus petit)

ConsidÃ©rons le nombre r/2.

Puisque r > 0, nous avons r/2 = r Â· (1/2) > 0 Â· (1/2) = 0.
Donc r/2 est un nombre rÃ©el positif.

Par notre hypothÃ¨se, puisque r est le plus petit nombre rÃ©el positif et que r/2 est un nombre rÃ©el positif, nous devons avoir :
r â‰¤ r/2

Multiplions les deux cÃ´tÃ©s par 2 :
2r â‰¤ r

Soustrayons r des deux cÃ´tÃ©s :
r â‰¤ 0

Mais nous avons supposÃ© que r > 0.

Donc nous avons r > 0 et r â‰¤ 0, ce qui est une contradiction.

Par consÃ©quent, notre hypothÃ¨se Ã©tait fausse : il n'existe pas de plus petit nombre rÃ©el positif. âˆ

---

### Exercice 2 : Niveau Moyen - Preuves par induction

**Ã‰noncÃ©** : Prouvez les thÃ©orÃ¨mes suivants en utilisant l'induction mathÃ©matique.

**a)** Pour tout entier n â‰¥ 1, 1Â² + 2Â² + 3Â² + ... + nÂ² = n(n+1)(2n+1)/6.

**b)** Pour tout entier n â‰¥ 1, 2â¿ â‰¥ n + 1.

**c)** Pour tout entier n â‰¥ 4, 2â¿ < n!.

**d)** Pour tout entier n â‰¥ 1, 1/(1Â·2) + 1/(2Â·3) + 1/(3Â·4) + ... + 1/(n(n+1)) = n/(n+1).

**CritÃ¨res d'Ã©valuation** :
- Cas de base vÃ©rifiÃ© correctement (1 point par preuve)
- HypothÃ¨se d'induction Ã©noncÃ©e explicitement (1 point par preuve)
- Ã‰tape d'induction logiquement correcte (2 points par preuve)
- Utilisation explicite de l'hypothÃ¨se d'induction (1 point par preuve)

**Indice** : Pour (a), l'algÃ¨bre peut devenir un peu lourde dans l'Ã©tape d'induction. Factorisez soigneusement. Pour (b) et (c), vous travaillez avec des inÃ©galitÃ©s, donc pensez Ã  comment manipuler l'hypothÃ¨se d'induction pour arriver Ã  l'inÃ©galitÃ© voulue. Pour (d), utilisez l'algÃ¨bre des fractions.

**Solution partielle pour (b)** :

**ThÃ©orÃ¨me** : Pour tout entier n â‰¥ 1, 2â¿ â‰¥ n + 1.

**Preuve par induction sur n** :

**Cas de base (n = 1)** :
2Â¹ = 2 â‰¥ 2 = 1 + 1. âœ“

**Ã‰tape d'induction** :
Soit k â‰¥ 1 un entier quelconque.

HypothÃ¨se d'induction : Supposons que 2áµ â‰¥ k + 1.

Nous voulons montrer que 2^{k+1} â‰¥ (k+1) + 1 = k + 2.

Calcul :
2^{k+1} = 2 Â· 2áµ
        â‰¥ 2 Â· (k + 1)     [par l'hypothÃ¨se d'induction]
        = 2k + 2
        = k + 2 + k

Puisque k â‰¥ 1, nous avons k â‰¥ 0, donc :
k + 2 + k â‰¥ k + 2

Par transitivitÃ© :
2^{k+1} â‰¥ k + 2. âœ“

Par le principe d'induction mathÃ©matique, 2â¿ â‰¥ n + 1 pour tout n â‰¥ 1. âˆ

---

### Exercice 3 : Niveau Difficile - Correction d'algorithme rÃ©cursif

**Ã‰noncÃ©** : Vous implÃ©mentez une fonction rÃ©cursive pour calculer le niÃ¨me nombre de Catalan, qui apparaÃ®t dans de nombreux problÃ¨mes combinatoires.

La suite de Catalan est dÃ©finie par :
- C(0) = 1
- C(n) = Î£(i=0 to n-1) C(i) Ã— C(n-1-i) pour n â‰¥ 1

Les premiers termes sont : C(0)=1, C(1)=1, C(2)=2, C(3)=5, C(4)=14, ...

**ImplÃ©mentation rÃ©cursive naÃ¯ve** :

```javascript
function catalan(n) {
  if (n === 0) {
    return 1;
  }
  
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += catalan(i) * catalan(n - 1 - i);
  }
  return sum;
}
```

**TÃ¢ches** :

1. **Prouvez formellement** que cette fonction calcule correctement C(n) pour tout n â‰¥ 0 en utilisant l'induction forte. Votre preuve doit Ãªtre complÃ¨te avec cas de base, hypothÃ¨se d'induction explicite, et Ã©tape d'induction dÃ©taillÃ©e.

2. **Analysez la complexitÃ© temporelle** de cette implÃ©mentation. Ã‰tablissez une relation de rÃ©currence pour T(n) (le nombre d'appels Ã  `catalan`), puis prouvez par induction que T(n) est exponentielle en n.

3. **ImplÃ©mentez une version optimisÃ©e** utilisant la mÃ©moÃ¯sation (mise en cache des rÃ©sultats) :

```javascript
function catalanMemo(n, memo = {}) {
  // TODO: ComplÃ©tez cette implÃ©mentation
}
```

4. **Prouvez que la version mÃ©moÃ¯sÃ©e est correcte** : montrez qu'elle retourne le mÃªme rÃ©sultat que la version naÃ¯ve tout en Ã©tant plus efficace.

5. **Analysez la complexitÃ© de la version mÃ©moÃ¯sÃ©e** et prouvez qu'elle est polynomiale en n.

6. **Extension** : Utilisez une formule fermÃ©e pour les nombres de Catalan :
   C(n) = (1/(n+1)) Ã— (2n choose n) = (2n)! / ((n+1)! Ã— n!)
   
   ImplÃ©mentez cette formule et prouvez qu'elle donne le mÃªme rÃ©sultat que la dÃ©finition rÃ©cursive.

**CritÃ¨res d'Ã©valuation** :
- Preuve de correction formelle et complÃ¨te (4 points)
- Analyse de complexitÃ© avec relation de rÃ©currence (3 points)
- ImplÃ©mentation mÃ©moÃ¯sÃ©e correcte (2 points)
- Preuve de correction de la version mÃ©moÃ¯sÃ©e (2 points)
- Analyse de complexitÃ© de la version mÃ©moÃ¯sÃ©e (2 points)
- Extension avec formule fermÃ©e (2 points)

**Indice** : Pour la preuve par induction forte, vous aurez besoin de supposer que `catalan(i)` est correct pour tout i â‰¤ k. Pour la mÃ©moÃ¯sation, stockez les rÃ©sultats dÃ©jÃ  calculÃ©s dans l'objet `memo`. Pour prouver la complexitÃ© de la version mÃ©moÃ¯sÃ©e, comptez combien de fois chaque valeur de n est calculÃ©e (au plus une fois).

*Note : Cet exercice est consÃ©quent. Il n'y a pas de solution complÃ¨te fournie pour vous permettre de le dÃ©velopper en autonomie. C'est un excellent test de votre maÃ®trise de l'induction et de votre capacitÃ© Ã  l'appliquer Ã  l'analyse d'algorithmes.*

---

## ğŸ“š Ressources recommandÃ©es

### Ressource 1 (PrioritÃ© maximale) : Cours MIT - Induction

**Type** : Cours vidÃ©o et notes  
**Titre** : MIT 6.042J Mathematics for Computer Science - Lecture 2 (Induction)  
**Professeurs** : Albert Meyer et Adam Chlipala  
**DisponibilitÃ©** : Gratuit sur MIT OpenCourseWare

**Pourquoi cette ressource est recommandÃ©e** : Cette lecture du MIT est considÃ©rÃ©e comme l'une des meilleures introductions Ã  l'induction mathÃ©matique. Les professeurs prÃ©sentent non seulement la mÃ©canique de l'induction, mais aussi l'intuition profonde derriÃ¨re la technique. Ils montrent de nombreux exemples d'erreurs courantes (comme la "preuve" que tous les chevaux sont de la mÃªme couleur) et expliquent exactement oÃ¹ ces preuves Ã©chouent. Les notes de cours contiennent des exercices progressifs avec solutions dÃ©taillÃ©es.

---

### Ressource 2 (PrioritÃ© maximale) : Livre classique sur les preuves

**Type** : Livre  
**Titre** : "How to Prove It: A Structured Approach" (3e Ã©dition)  
**Auteur** : Daniel J. Velleman  
**Sections pertinentes** : Chapitre 5 (Proof by Contradiction), Chapitre 6 (Mathematical Induction)

**Pourquoi cette ressource est recommandÃ©e** : Velleman explique la preuve par contradiction de maniÃ¨re particuliÃ¨rement claire, avec de nombreux exemples qui dÃ©veloppent l'intuition. Son chapitre sur l'induction est Ã©galement excellent, avec une progression trÃ¨s pÃ©dagogique de l'induction simple vers l'induction forte. Chaque section contient des exercices soigneusement graduÃ©s qui renforcent la comprÃ©hension.

---

### Ressource 3 (PrioritÃ© haute) : VidÃ©os pÃ©dagogiques

**Type** : SÃ©rie de vidÃ©os  
**Titre** : "Mathematical Induction - Art of Problem Solving"  
**Plateforme** : YouTube / Art of Problem Solving

**Pourquoi cette ressource est recommandÃ©e** : Ces vidÃ©os adoptent une approche trÃ¨s visuelle de l'induction, utilisant des animations pour illustrer l'analogie des dominos et montrer comment les preuves se construisent. Les exemples sont bien choisis et progressent en difficultÃ©. La prÃ©sentation est engageante et aide Ã  dÃ©velopper l'intuition avant de plonger dans les dÃ©tails formels.

---

### Ressource 4 (PrioritÃ© haute) : Exercices interactifs

**Type** : Plateforme d'apprentissage  
**Titre** : "Proof by Induction" - Brilliant.org  
**DisponibilitÃ©** : Gratuit (avec version premium)

**Pourquoi cette ressource est recommandÃ©e** : Brilliant propose des exercices interactifs sur l'induction oÃ¹ vous construisez des preuves Ã©tape par Ã©tape avec feedback immÃ©diat. La plateforme vous guide dans la construction de la preuve en vous posant des questions ciblÃ©es. C'est particuliÃ¨rement utile pour dÃ©velopper votre capacitÃ© Ã  identifier quand utiliser l'induction simple vs l'induction forte.

---

### Ressource 5 (PrioritÃ© moyenne) : Applications en informatique

**Type** : Notes de cours  
**Titre** : "Structural Induction" - Carnegie Mellon University  
**Contexte** : Notes du cours 15-150 (Principles of Functional Programming)

**Pourquoi cette ressource est recommandÃ©e** : Ces notes montrent comment l'induction s'Ã©tend au-delÃ  des entiers naturels pour s'appliquer Ã  des structures rÃ©cursives comme les listes, les arbres, et les types de donnÃ©es inductifs. C'est essentiel pour prouver la correction d'algorithmes sur ces structures. Les exemples en OCaml sont particuliÃ¨rement Ã©clairants pour comprendre le lien entre dÃ©finitions inductives et preuves inductives.

---

### Ressource 6 (PrioritÃ© moyenne) : Article historique

**Type** : Article  
**Titre** : "What is Wrong with These Inductive Proofs?" - Numerous mathematical educators  
**Contexte** : Collections d'exemples de preuves inductives erronÃ©es

**Pourquoi cette ressource est recommandÃ©e** : Cet article compile de nombreuses "preuves" erronÃ©es cÃ©lÃ¨bres utilisant l'induction (tous les chevaux ont la mÃªme couleur, tous les entiers sont intÃ©ressants, etc.) et analyse prÃ©cisÃ©ment oÃ¹ chacune Ã©choue. Ã‰tudier les erreurs est souvent aussi instructif qu'Ã©tudier les preuves correctes. Cela dÃ©veloppe votre sens critique et vous aide Ã  Ã©viter ces piÃ¨ges dans vos propres preuves.

---

## ğŸ“Š Grille d'Ã©valuation

### CritÃ¨re 1 : MaÃ®trise de la preuve par contradiction (5 points)

**5 points** : CapacitÃ© Ã  reconnaÃ®tre les situations oÃ¹ la preuve par contradiction est appropriÃ©e, Ã  supposer correctement la nÃ©gation de ce qu'on veut prouver, Ã  dÃ©river une chaÃ®ne logique menant Ã  une contradiction claire, et Ã  conclure correctement.

**4 points** : Preuves gÃ©nÃ©ralement correctes mais parfois difficultÃ© Ã  identifier la forme de contradiction la plus efficace ou confusion occasionnelle avec la preuve par contraposÃ©e.

**3 points** : CapacitÃ© Ã  construire des preuves par contradiction simples mais difficultÃ© avec les cas oÃ¹ la contradiction est subtile ou nÃ©cessite plusieurs Ã©tapes.

**2 points** : ComprÃ©hension du principe gÃ©nÃ©ral mais erreurs frÃ©quentes dans l'identification de ce qui constitue une contradiction ou dans la conclusion.

**1 point** : Tentatives de preuve par contradiction mais avec des erreurs logiques majeures ou confusion avec d'autres techniques.

**0 point** : IncomprÃ©hension de la preuve par contradiction.

---

### CritÃ¨re 2 : Induction simple (5 points)

**5 points** : Construction parfaite de preuves par induction avec cas de base correctement vÃ©rifiÃ©, hypothÃ¨se d'induction explicitement Ã©noncÃ©e, et Ã©tape d'induction rigoureuse utilisant correctement l'hypothÃ¨se d'induction.

**4 points** : Preuves gÃ©nÃ©ralement correctes mais avec des Ã©tapes occasionnellement non justifiÃ©es ou des transitions trop rapides entre l'hypothÃ¨se d'induction et la conclusion.

**3 points** : Structure de base correcte (cas de base + Ã©tape d'induction) mais avec des lacunes dans la rigueur ou difficultÃ© Ã  manipuler algÃ©briquement les expressions dans l'Ã©tape d'induction.

**2 points** : Tentative de preuve par induction mais avec oubli du cas de base, hypothÃ¨se d'induction mal formulÃ©e, ou raisonnement circulaire dans l'Ã©tape d'induction.

**1 point** : Confusion majeure sur le fonctionnement de l'induction, comme supposer P(k+1) au lieu de P(k).

**0 point** : IncomprÃ©hension du principe d'induction.

---

### CritÃ¨re 3 : Induction forte (4 points)

**4 points** : Reconnaissance correcte des situations nÃ©cessitant l'induction forte, formulation appropriÃ©e de l'hypothÃ¨se d'induction forte (supposer P(i) pour tout i de nâ‚€ Ã  k), et utilisation correcte de cette hypothÃ¨se Ã©tendue dans la preuve.

**3 points** : CapacitÃ© Ã  utiliser l'induction forte quand indiquÃ©, mais parfois utilisation non optimale (induction forte lÃ  oÃ¹ l'induction simple suffirait) ou justification insuffisante de pourquoi l'induction forte est nÃ©cessaire.

**2 points** : ComprÃ©hension du principe mais difficultÃ© Ã  identifier correctement les valeurs de i pour lesquelles on a besoin d'appliquer l'hypothÃ¨se.

**1 point** : Confusion entre induction simple et forte, ou application incorrecte de l'hypothÃ¨se d'induction forte.

**0 point** : IncomprÃ©hension de l'induction forte.

---

### CritÃ¨re 4 : Induction et algorithmes rÃ©cursifs (4 points)

**4 points** : CapacitÃ© parfaite Ã  prouver la correction d'algorithmes rÃ©cursifs par induction, avec correspondance claire entre le cas de base de l'algorithme et le cas de base de l'induction, et entre l'Ã©tape rÃ©cursive et l'Ã©tape d'induction.

**3 points** : Preuves gÃ©nÃ©ralement correctes mais avec des imprÃ©cisions dans la correspondance entre le code et la preuve, ou gestion incomplÃ¨te de tous les cas de l'algorithme.

**2 points** : ComprÃ©hension du principe mais difficultÃ© Ã  formaliser la preuve ou Ã  gÃ©rer les algorithmes avec plusieurs appels rÃ©cursifs.

**1 point** : Tentative de preuve mais avec des erreurs logiques ou incomprÃ©hension de comment l'hypothÃ¨se d'induction correspond Ã  l'appel rÃ©cursif.

**0 point** : IncapacitÃ© Ã  appliquer l'induction aux algorithmes rÃ©cursifs.

---

### CritÃ¨re 5 : DÃ©tection d'erreurs en induction (3 points)

**3 points** : CapacitÃ© Ã  identifier correctement les erreurs courantes (cas de base manquant, hypothÃ¨se circulaire, gÃ©nÃ©ralisation incorrecte) dans des preuves par induction erronÃ©es et Ã  expliquer prÃ©cisÃ©ment pourquoi elles invalident la preuve.

**2 points** : DÃ©tection des erreurs les plus Ã©videntes (cas de base clairement faux) mais difficultÃ© avec les erreurs plus subtiles comme les preuves qui semblent correctes mais font un saut logique injustifiÃ©.

**1 point** : CapacitÃ© limitÃ©e Ã  identifier les erreurs ou confusion sur ce qui constitue une erreur vs une variation acceptable de style.

**0 point** : IncapacitÃ© Ã  distinguer les preuves correctes des incorrectes.

---

### BarÃ¨me de notation global

**19-21 points** : Excellent. MaÃ®trise complÃ¨te de la preuve par contradiction et de l'induction mathÃ©matique, avec capacitÃ© Ã  les appliquer Ã  des problÃ¨mes algorithmiques rÃ©els.

**16-18 points** : TrÃ¨s bien. Bonne maÃ®trise avec quelques imperfections mineures dans les cas les plus complexes ou les applications avancÃ©es.

**13-15 points** : Bien. ComprÃ©hension solide des techniques de base avec capacitÃ© Ã  construire des preuves simples, mais difficultÃ© avec les cas nÃ©cessitant plus de crÃ©ativitÃ© ou de manipulations sophistiquÃ©es.

**10-12 points** : Passable. ComprÃ©hension des principes gÃ©nÃ©raux mais nÃ©cessite plus de pratique pour construire des preuves complÃ¨tes et rigoureuses.

**< 10 points** : Insuffisant. RÃ©vision substantielle nÃ©cessaire. Il est crucial de bien maÃ®triser ces techniques avant de progresser vers l'Ã©tude d'algorithmes avancÃ©s.

---

## ğŸ“ Conclusion de la leÃ§on

Vous venez de complÃ©ter la derniÃ¨re leÃ§on du Chapitre 1 sur la logique et les preuves, et vous avez maintenant un arsenal complet de techniques de dÃ©monstration ! La preuve par contradiction et l'induction mathÃ©matique sont probablement les deux outils les plus puissants que vous utiliserez tout au long de votre parcours en informatique thÃ©orique et pratique.

**Concepts clÃ©s Ã  retenir** :

La preuve par contradiction repose sur la loi du tiers exclu et fonctionne en supposant que ce que nous voulons prouver est faux, puis en montrant que cette supposition mÃ¨ne inÃ©vitablement Ã  une contradiction logique. Cette technique est particuliÃ¨rement puissante pour prouver des Ã©noncÃ©s nÃ©gatifs ("il n'existe pas...", "aucun nombre ne...") ou pour Ã©tablir l'irrationnalitÃ© de nombres. Les preuves classiques comme l'irrationnalitÃ© de âˆš2 et l'infinitude des nombres premiers montrent l'Ã©lÃ©gance et la puissance de cette mÃ©thode.

L'induction mathÃ©matique est votre outil de prÃ©dilection pour prouver des propriÃ©tÃ©s sur les entiers naturels et, par extension, sur toute structure dÃ©finie rÃ©cursivement. Le principe est simple mais profond : prouvez que la propriÃ©tÃ© est vraie pour le cas de base, puis prouvez que si elle est vraie pour k, elle l'est aussi pour k+1. Ces deux Ã©tapes ensemble garantissent qu'elle est vraie pour tous les entiers Ã  partir du cas de base. L'analogie des dominos capture parfaitement cette idÃ©e.

L'induction forte Ã©tend l'induction simple en vous permettant de supposer que la propriÃ©tÃ© est vraie pour tous les cas prÃ©cÃ©dents, pas seulement pour k. Bien qu'elle ne soit pas logiquement plus puissante, elle rend certaines preuves beaucoup plus naturelles, notamment quand l'Ã©tape inductive nÃ©cessite plusieurs cas prÃ©cÃ©dents ou quand la rÃ©duction n'est pas simplement de k Ã  k-1.

La correspondance entre l'induction et la rÃ©cursivitÃ© est profonde et pratique. Chaque fonction rÃ©cursive a une structure qui se prÃªte naturellement Ã  une preuve par induction : le cas de base de la rÃ©cursion devient le cas de base de l'induction, et l'Ã©tape rÃ©cursive correspond Ã  l'Ã©tape d'induction. Cette correspondance fait de l'induction l'outil idÃ©al pour prouver la correction d'algorithmes rÃ©cursifs.

**PiÃ¨ges Ã  Ã©viter absolument** : N'oubliez jamais le cas de base dans vos preuves par induction. C'est l'erreur la plus frÃ©quente et elle invalide complÃ¨tement la preuve. Ne confondez pas "supposer P(k)" (hypothÃ¨se d'induction, correct) avec "supposer P(k+1)" (ce que vous voulez prouver, circulaire). Dans les preuves par contradiction, assurez-vous que votre contradiction est rÃ©elle et pas simplement une consÃ©quence inattendue qui pourrait Ãªtre vraie.

**Application pratique immÃ©diate** : Ã€ partir de maintenant, quand vous Ã©crivez une fonction rÃ©cursive, prenez l'habitude de vous demander : "Comment prouverais-je par induction que cette fonction est correcte ?" Cette discipline mentale vous aidera Ã  Ã©crire des fonctions rÃ©cursives plus claires et Ã  identifier les bugs potentiels avant mÃªme de les tester.

**Prochaines Ã©tapes** : Vous avez maintenant terminÃ© le Chapitre 1 sur la Logique et Preuves. Vous possÃ©dez les quatre techniques de preuve fondamentales (directe, contraposÃ©e, contradiction, induction) qui forment la base de tout raisonnement mathÃ©matique rigoureux en informatique. Dans le Chapitre 2, vous appliquerez ces techniques pour prouver des propriÃ©tÃ©s sur les ensembles, les relations, et les fonctions. Vous verrez comment l'induction s'Ã©tend Ã  l'induction structurelle pour prouver des propriÃ©tÃ©s sur des structures de donnÃ©es rÃ©cursives comme les listes et les arbres.

**Vision d'ensemble** : Les quatre leÃ§ons de ce chapitre vous ont fourni un fondement solide en logique formelle et en techniques de preuve. Ces compÃ©tences ne sont pas seulement acadÃ©miques. Elles changeront votre faÃ§on de penser les problÃ¨mes algorithmiques. Vous ne vous contenterez plus de tester quelques cas et d'espÃ©rer que votre code fonctionne. Vous pourrez raisonner rigoureusement sur la correction de vos algorithmes, analyser formellement leur complexitÃ©, et identifier les bugs potentiels par analyse logique avant mÃªme l'exÃ©cution.

Prenez le temps de bien assimiler ces concepts avant de continuer. Pratiquez en construisant vos propres preuves pour des thÃ©orÃ¨mes simples. Cherchez des preuves par induction dans les articles et livres que vous lisez. Avec la pratique, ce qui semble aujourd'hui laborieux deviendra une seconde nature, et vous dÃ©velopperez l'intuition qui vous dira immÃ©diatement quelle technique de preuve utiliser pour un problÃ¨me donnÃ©.

FÃ©licitations pour avoir complÃ©tÃ© ce chapitre fondamental ! Vous Ãªtes maintenant Ã©quipÃ© pour aborder les mathÃ©matiques discrÃ¨tes et l'analyse d'algorithmes avec confiance et rigueur.

---

**DerniÃ¨re mise Ã  jour** : Janvier 2026  
**Auteur** : Curriculum Computer Science - Version 1.0