# üìö Module 1 - Chapitre 1 - Le√ßon 3
# Techniques de preuve : preuve directe et contrapos√©e

---

## üìã M√©tadonn√©es de la le√ßon

**Identifiant** : M1.C1.L3  
**Titre** : Techniques de preuve : preuve directe et contrapos√©e  
**Pr√©requis** : M1.C1.L2 (Logique des pr√©dicats et quantificateurs)  
**Temps d'√©tude estim√©** : 6 heures

---

## üéØ Objectifs d'apprentissage

√Ä la fin de cette le√ßon, vous serez capable de :

1. **D√©finir rigoureusement** ce qu'est une preuve math√©matique et distinguer entre une preuve valide et un argument informel ou incomplet, en identifiant les composantes essentielles d'une d√©monstration formelle.

2. **Construire des preuves directes** en partant des hypoth√®ses pour arriver √† la conclusion par une cha√Æne d'implications logiques valides, en utilisant des d√©finitions formelles, des axiomes, et des th√©or√®mes pr√©c√©demment √©tablis.

3. **Appliquer la technique de la contrapos√©e** en reconnaissant les situations o√π prouver ¬¨Q ‚Üí ¬¨P est plus simple que prouver P ‚Üí Q, et en construisant correctement la preuve de la contrapos√©e.

4. **Justifier chaque √©tape d'une preuve** en citant explicitement les d√©finitions, propri√©t√©s, ou r√©sultats utilis√©s, et en maintenant une rigueur logique tout au long de la d√©monstration.

5. **Prouver la correction partielle d'algorithmes simples** en √©tablissant que si l'algorithme termine, alors il produit le r√©sultat correct, en utilisant les techniques de preuve directe et contrapos√©e.

6. **Identifier et corriger des preuves erron√©es** en rep√©rant les erreurs logiques courantes telles que l'affirmation du cons√©quent, le raisonnement circulaire, ou les sauts injustifi√©s dans la cha√Æne de raisonnement.

---

## üìñ Contenu exhaustif de la le√ßon

### üîç 1. Qu'est-ce qu'une preuve math√©matique ?

Imaginez que vous √™tes en train d'expliquer √† un coll√®gue pourquoi votre fonction de validation fonctionne toujours correctement. Vous ne vous contentez pas de dire "Fais-moi confiance, √ßa marche" ou "J'ai test√© quelques cas". Vous construisez un argument logique qui part de ce que vous savez √™tre vrai (les hypoth√®ses) et qui d√©montre, √©tape par √©tape, pourquoi votre conclusion doit n√©cessairement √™tre vraie. C'est exactement ce qu'est une preuve math√©matique, mais avec un niveau de rigueur et de formalisme plus √©lev√©.

#### D√©finition formelle

Une **preuve math√©matique** (ou **d√©monstration**) est une s√©quence finie d'√©nonc√©s logiques o√π chaque √©nonc√© est soit une hypoth√®se (donn√©e comme vraie), soit d√©coule logiquement des √©nonc√©s pr√©c√©dents par l'application de r√®gles d'inf√©rence valides. La preuve commence par les hypoth√®ses et se termine par la conclusion que l'on souhaite √©tablir.

Plus formellement, une preuve de l'√©nonc√© P ‚Üí Q est une s√©quence d'√©nonc√©s S‚ÇÅ, S‚ÇÇ, S‚ÇÉ, ..., S‚Çô o√π :
- S‚ÇÅ est l'hypoth√®se P (ou d√©coule directement de P)
- S‚Çô est la conclusion Q
- Pour chaque S·µ¢ (o√π i > 1), S·µ¢ est obtenu √† partir de S‚ÇÅ, S‚ÇÇ, ..., S·µ¢‚Çã‚ÇÅ par l'application d'une r√®gle d'inf√©rence valide

#### Composantes d'une preuve

Une preuve bien construite contient les √©l√©ments suivants :

**√ânonc√© du th√©or√®me** : Une formulation claire et pr√©cise de ce que l'on veut d√©montrer, g√©n√©ralement sous la forme "Si P alors Q" ou "Pour tout x, si P(x) alors Q(x)".

**Hypoth√®ses** : Les conditions que l'on suppose vraies au d√©part. Elles doivent √™tre √©nonc√©es explicitement.

**Corps de la preuve** : La cha√Æne de raisonnement qui va des hypoth√®ses √† la conclusion. Chaque √©tape doit √™tre justifi√©e.

**Conclusion** : L'√©nonc√© final que l'on a √©tabli comme vrai. Souvent marqu√© par des symboles comme ‚àé, ‚ñ°, ou Q.E.D. (Quod Erat Demonstrandum - "ce qu'il fallait d√©montrer").

#### Ce qu'une preuve n'est pas

Il est important de comprendre ce qui ne constitue pas une preuve valide :

**V√©rification d'exemples** : Tester quelques cas particuliers ne prouve pas qu'une propri√©t√© est vraie pour tous les cas. Par exemple, v√©rifier que 2¬≤ + 1 = 5 (premier), 4¬≤ + 1 = 17 (premier), 6¬≤ + 1 = 37 (premier) ne prouve pas que n¬≤ + 1 est toujours premier (contre-exemple : 5¬≤ + 1 = 26 n'est pas premier).

**Arguments par analogie** : "Cette situation ressemble √† telle autre o√π c'est vrai, donc c'est vrai ici aussi" n'est pas une preuve.

**Appel √† l'intuition** : "C'est √©vident" ou "Cela semble raisonnable" ne sont pas des arguments valides dans une preuve formelle.

**Raisonnement circulaire** : Utiliser la conclusion comme hypoth√®se pour prouver la conclusion.

#### Niveaux de rigueur

En pratique, le niveau de d√©tail dans une preuve peut varier selon le contexte et l'audience. Pensez-y comme √† des niveaux de zoom sur une carte. √Ä un niveau tr√®s formel (comme dans les syst√®mes de preuve automatis√©s), chaque √©tape logique √©l√©mentaire doit √™tre explicite. √Ä un niveau plus habituel (comme dans les articles acad√©miques ou les cours universitaires), on peut omettre les √©tapes consid√©r√©es comme "√©videntes" pour un lecteur ayant les connaissances appropri√©es. Dans tous les cas, la preuve doit pouvoir √™tre rendue compl√®tement formelle si n√©cessaire.

Pour votre apprentissage, je vous encourage √† √™tre tr√®s explicite au d√©but. Justifiez chaque √©tape, m√™me celles qui vous semblent √©videntes. Cette discipline vous aidera √† d√©velopper une rigueur qui deviendra naturelle avec la pratique, et vous √©vitera de faire des sauts logiques injustifi√©s.

---

### üìê 2. La preuve directe

La preuve directe est la technique la plus naturelle et la plus fr√©quemment utilis√©e. L'id√©e est simple : on commence avec l'hypoth√®se P et on applique une s√©rie de d√©ductions logiques jusqu'√† arriver √† la conclusion Q.

#### Structure d'une preuve directe

Consid√©rons un th√©or√®me de la forme "Si P alors Q" (ou P ‚Üí Q).

**√âtape 1 - Hypoth√®se** : On suppose que P est vrai. Cette supposition est explicitement √©nonc√©e au d√©but de la preuve.

**√âtape 2 - D√©veloppement** : On applique des d√©finitions, des axiomes, des th√©or√®mes pr√©c√©demment √©tablis, et des r√®gles d'inf√©rence pour d√©duire de nouveaux √©nonc√©s vrais.

**√âtape 3 - Conclusion** : On aboutit √† Q, ce qui compl√®te la preuve.

#### Template formel pour une preuve directe

Voici un mod√®le que vous pouvez suivre :

```
Th√©or√®me : Si P alors Q.

Preuve : 
  Supposons que P soit vrai.
  [D√©finition ou d√©veloppement de P]
  ...
  [S√©rie d'implications logiques]
  ...
  Donc Q est vrai.
‚àé
```

#### Exemple simple : Preuve sur les nombres pairs

**Th√©or√®me** : Si n est un nombre entier pair, alors n¬≤ est pair.

**Preuve directe** :

Supposons que n soit un nombre entier pair.

Par d√©finition, un nombre entier est pair s'il peut s'√©crire sous la forme 2k pour un certain entier k. Donc, il existe un entier k tel que n = 2k.

Calculons n¬≤ :
n¬≤ = (2k)¬≤
   = 4k¬≤
   = 2(2k¬≤)

Posons m = 2k¬≤. Puisque k est un entier, m = 2k¬≤ est √©galement un entier.

Nous avons donc n¬≤ = 2m o√π m est un entier.

Par d√©finition, cela signifie que n¬≤ est pair.

Donc, si n est pair, alors n¬≤ est pair. ‚àé

**Analyse de la preuve** : Remarquez comment chaque √©tape est justifi√©e. Nous avons utilis√© la d√©finition de "pair" √† deux reprises : une fois pour d√©velopper l'hypoth√®se (n est pair donc n = 2k), et une fois pour √©tablir la conclusion (n¬≤ = 2m donc n¬≤ est pair). Les manipulations alg√©briques entre ces deux utilisations sont des applications de propri√©t√©s arithm√©tiques bien connues.

#### Exemple avec quantificateurs : Propri√©t√© de transitivit√©

**Th√©or√®me** : Pour tous entiers a, b, c, si a < b et b < c, alors a < c.

**Preuve directe** :

Soient a, b, c des entiers quelconques.

Supposons que a < b et b < c.

Par d√©finition de l'in√©galit√© stricte sur les entiers, a < b signifie que b - a ‚â• 1, et b < c signifie que c - b ‚â• 1.

Additionnons ces deux in√©galit√©s :
(b - a) + (c - b) ‚â• 1 + 1
b - a + c - b ‚â• 2
c - a ‚â• 2

Puisque c - a ‚â• 2, nous avons certainement c - a ‚â• 1, ce qui signifie par d√©finition que a < c.

Donc, si a < b et b < c, alors a < c. ‚àé

**Point p√©dagogique important** : Cette preuve montre comment on utilise des d√©finitions formelles (ici, la d√©finition de < en termes d'in√©galit√©s sur les diff√©rences) pour transformer un √©nonc√© en quelque chose de manipulable alg√©briquement. C'est une technique fondamentale : quand vous √™tes bloqu√© dans une preuve, revenez aux d√©finitions formelles des termes utilis√©s.

---

### üîÑ 3. La preuve par contrapos√©e

La contrapos√©e de l'implication P ‚Üí Q est l'implication ¬¨Q ‚Üí ¬¨P ("si non Q, alors non P"). Un r√©sultat fondamental de la logique propositionnelle, que vous avez vu dans la le√ßon M1.C1.L1, est que ces deux implications sont logiquement √©quivalentes.

#### √âquivalence logique fondamentale

**Th√©or√®me** : P ‚Üí Q ‚â° ¬¨Q ‚Üí ¬¨P

**Justification** : Construisons la table de v√©rit√© pour v√©rifier cette √©quivalence.

| P | Q | P ‚Üí Q | ¬¨Q | ¬¨P | ¬¨Q ‚Üí ¬¨P |
|---|---|-------|----|----|---------|
| V | V | V     | F  | F  | V       |
| V | F | F     | V  | F  | F       |
| F | V | V     | F  | V  | V       |
| F | F | V     | V  | V  | V       |

Les colonnes "P ‚Üí Q" et "¬¨Q ‚Üí ¬¨P" sont identiques, confirmant l'√©quivalence.

Cette √©quivalence est pr√©cieuse car elle nous donne une strat√©gie alternative : si prouver directement P ‚Üí Q est difficile, nous pouvons essayer de prouver ¬¨Q ‚Üí ¬¨P √† la place.

#### Quand utiliser la contrapos√©e ?

La preuve par contrapos√©e est particuli√®rement utile dans les situations suivantes :

**Situation 1** : L'hypoth√®se P est difficile √† d√©velopper ou √† utiliser directement, mais sa n√©gation ¬¨P est plus maniable.

**Situation 2** : La conclusion Q est difficile √† √©tablir directement, mais sa n√©gation ¬¨Q fournit une hypoth√®se de travail utile.

**Situation 3** : La forme de l'√©nonc√© sugg√®re naturellement un raisonnement par contrapos√©e, notamment quand la conclusion est une n√©gation ou une in√©galit√©.

**Heuristique pratique** : Si vous vous retrouvez avec une conclusion de la forme "x n'est pas..." ou "il n'existe pas...", essayez la contrapos√©e. De m√™me, si l'hypoth√®se contient beaucoup de n√©gations qui rendent le raisonnement direct compliqu√©, la contrapos√©e pourrait simplifier les choses.

#### Template formel pour une preuve par contrapos√©e

```
Th√©or√®me : Si P alors Q.

Preuve (par contrapos√©e) : 
  Nous allons prouver la contrapos√©e : si ¬¨Q alors ¬¨P.
  Supposons que ¬¨Q soit vrai.
  [D√©veloppement de ¬¨Q]
  ...
  [S√©rie d'implications logiques]
  ...
  Donc ¬¨P est vrai.
  Par √©quivalence de la contrapos√©e, nous avons prouv√© que P ‚Üí Q.
‚àé
```

#### Exemple : Preuve sur les carr√©s

**Th√©or√®me** : Pour tout entier n, si n¬≤ est impair, alors n est impair.

**Analyse pr√©liminaire** : Si nous essayions une preuve directe, nous partirions de "n¬≤ est impair" et nous devrions en d√©duire "n est impair". Mais comment manipuler l'hypoth√®se "n¬≤ est impair" ? C'est moins √©vident. En revanche, la contrapos√©e nous donne une hypoth√®se beaucoup plus maniable : "n est pair", qui a une d√©finition alg√©brique claire (n = 2k).

**Preuve par contrapos√©e** :

Nous allons prouver la contrapos√©e : si n est pair, alors n¬≤ est pair.

Supposons que n soit pair.

Par d√©finition, il existe un entier k tel que n = 2k.

Calculons n¬≤ :
n¬≤ = (2k)¬≤
   = 4k¬≤
   = 2(2k¬≤)

Posons m = 2k¬≤. Puisque k est un entier, m est un entier.

Donc n¬≤ = 2m, ce qui signifie que n¬≤ est pair.

Nous avons prouv√© que si n est pair, alors n¬≤ est pair.

Par contrapos√©e, si n¬≤ est impair, alors n est impair. ‚àé

**Observation importante** : Notez que cette preuve par contrapos√©e est presque identique √† notre preuve directe pr√©c√©dente (que si n est pair, alors n¬≤ est pair). C'est souvent le cas : la preuve de la contrapos√©e peut r√©utiliser des r√©sultats que vous avez d√©j√† √©tablis.

#### Exemple plus subtil : Unicit√© d'un √©l√©ment

**Th√©or√®me** : Pour tous entiers a et b, si a + b est impair, alors a et b ne sont pas tous les deux pairs.

**Preuve par contrapos√©e** :

Nous allons prouver la contrapos√©e : si a et b sont tous les deux pairs, alors a + b est pair.

Supposons que a et b soient tous les deux pairs.

Par d√©finition, il existe des entiers k et m tels que a = 2k et b = 2m.

Calculons a + b :
a + b = 2k + 2m
      = 2(k + m)

Posons n = k + m. Puisque k et m sont des entiers, n est un entier.

Donc a + b = 2n, ce qui signifie que a + b est pair.

Nous avons prouv√© que si a et b sont tous les deux pairs, alors a + b est pair.

Par contrapos√©e, si a + b est impair, alors a et b ne sont pas tous les deux pairs. ‚àé

---

### ‚öñÔ∏è 4. Comparaison et choix de la m√©thode

Comment d√©cider entre une preuve directe et une preuve par contrapos√©e ? Voici un guide pratique bas√© sur l'exp√©rience.

#### Crit√®res de d√©cision

**Commencez toujours par essayer la preuve directe** : C'est l'approche la plus naturelle et la plus intuitive. Partez de l'hypoth√®se et voyez o√π elle vous m√®ne. Si apr√®s quelques minutes vous √™tes bloqu√© ou si les manipulations deviennent tr√®s complexes, consid√©rez la contrapos√©e.

**Examinez la structure logique de l'√©nonc√©** : Certaines formes d'√©nonc√©s se pr√™tent mieux √† une m√©thode qu'√† une autre.

Si la conclusion Q est une n√©gation (par exemple, "n n'est pas pair", "il n'existe pas de x tel que...", "f n'est pas injective"), la contrapos√©e transformera cette n√©gation en affirmation positive, souvent plus facile √† manipuler.

Si l'hypoth√®se P contient d√©j√† beaucoup de n√©gations ou de conditions disjonctives (P = ¬¨A ‚à® ¬¨B), la contrapos√©e pourrait simplifier en donnant ¬¨P = A ‚àß B.

**Consid√©rez les d√©finitions disponibles** : Quelle forme (P ou ¬¨P, Q ou ¬¨Q) a une d√©finition formelle plus exploitable ? Par exemple, "n est pair" a une d√©finition constructive claire (n = 2k), tandis que "n est impair" pourrait √™tre d√©fini n√©gativement comme "n n'est pas pair" ou positivement comme "n = 2k+1". Si une d√©finition est beaucoup plus maniable que l'autre, orientez votre preuve pour l'utiliser.

**Essayez les deux approches mentalement** : Avec l'exp√©rience, vous d√©velopperez l'intuition de reconna√Ætre rapidement quelle approche sera la plus fructueuse. En attendant, n'h√©sitez pas √† esquisser les premi√®res √©tapes des deux approches sur un brouillon pour voir laquelle semble la plus prometteuse.

#### Tableau r√©capitulatif

| Indicateur | Preuve directe | Preuve par contrapos√©e |
|-----------|---------------|----------------------|
| Hypoth√®se P facile √† d√©velopper | ‚úì | |
| Conclusion Q difficile √† √©tablir | | ‚úì |
| Conclusion Q est une n√©gation | | ‚úì |
| Hypoth√®se P contient des n√©gations | | ‚úì |
| Intuition claire du chemin P ‚Üí Q | ‚úì | |
| R√©sultats interm√©diaires connus sur P | ‚úì | |
| R√©sultats interm√©diaires connus sur ¬¨Q | | ‚úì |

#### Exemple montrant la diff√©rence d'efficacit√©

Consid√©rons le th√©or√®me suivant et comparons les deux approches.

**Th√©or√®me** : Pour tout entier n ‚â• 2, si n n'est pas divisible par aucun nombre premier p ‚â§ ‚àön, alors n est premier.

**Approche 1 - Preuve directe** (difficile) :

Supposons que n n'est pas divisible par aucun nombre premier p ‚â§ ‚àön.

Nous voulons montrer que n est premier, c'est-√†-dire que n n'a aucun diviseur propre entre 2 et n-1.

[√Ä ce stade, il n'est pas √©vident comment progresser. L'hypoth√®se n√©gative "n n'est pas divisible par..." est difficile √† manipuler constructivement.]

**Approche 2 - Preuve par contrapos√©e** (plus naturelle) :

Nous allons prouver la contrapos√©e : si n n'est pas premier, alors n est divisible par au moins un nombre premier p ‚â§ ‚àön.

Supposons que n ne soit pas premier.

Par d√©finition, cela signifie que n a un diviseur propre, c'est-√†-dire qu'il existe des entiers a et b avec 1 < a < n et 1 < b < n tels que n = ab.

Sans perte de g√©n√©ralit√©, supposons a ‚â§ b.

Alors a¬≤ ‚â§ ab = n, donc a ‚â§ ‚àön.

Maintenant, a > 1 et a divise n, donc a a au moins un diviseur premier p (par le th√©or√®me fondamental de l'arithm√©tique).

Ce diviseur premier p divise a, et a divise n, donc p divise n.

De plus, p ‚â§ a ‚â§ ‚àön.

Nous avons trouv√© un nombre premier p ‚â§ ‚àön qui divise n.

Par contrapos√©e, si n n'est pas divisible par aucun premier p ‚â§ ‚àön, alors n est premier. ‚àé

**Conclusion** : La preuve par contrapos√©e est nettement plus naturelle ici car l'hypoth√®se "n n'est pas premier" se d√©veloppe facilement en "n = ab pour certains a, b", tandis que l'hypoth√®se originale "n n'est pas divisible par..." est essentiellement n√©gative et difficile √† exploiter directement.

---

### üß© 5. Justification des √©tapes et rigueur

Un aspect crucial d'une bonne preuve est la justification explicite de chaque √©tape. Cela signifie que pour chaque assertion que vous faites, vous devez pouvoir identifier sur quel principe logique, d√©finition, axiome, ou th√©or√®me pr√©c√©dent vous vous appuyez.

#### Niveaux de justification

Dans une preuve formelle compl√®te, chaque √©tape de raisonnement devrait √™tre une application d'une r√®gle d'inf√©rence valide. En pratique, on groupe plusieurs √©tapes √©l√©mentaires et on les justifie par des appels √† des r√©sultats plus substantiels. Voici les types de justifications courantes :

**D√©finition** : Vous utilisez la d√©finition formelle d'un concept. Par exemple, "Par d√©finition de nombre pair, n = 2k pour un certain entier k".

**Axiome** : Vous utilisez une propri√©t√© admise comme vraie sans preuve. Par exemple, les propri√©t√©s de l'addition et de la multiplication des entiers.

**Th√©or√®me pr√©c√©dent** : Vous citez un r√©sultat d√©j√† √©tabli. Par exemple, "Par le th√©or√®me de Pythagore..." ou "D'apr√®s le r√©sultat √©tabli dans le Lemme 2...".

**R√®gle d'inf√©rence** : Vous appliquez une r√®gle logique. Par exemple, le modus ponens : de P et P ‚Üí Q, on d√©duit Q.

**Propri√©t√© alg√©brique** : Vous utilisez une manipulation alg√©brique valide. Par exemple, "En d√©veloppant le carr√©..." ou "En factorisant...".

#### Erreurs de raisonnement √† √©viter

Certaines erreurs logiques reviennent fr√©quemment dans les preuves incorrectes. Apprenons √† les reconna√Ætre pour les √©viter.

**Affirmation du cons√©quent** : C'est l'erreur qui consiste √† raisonner ainsi : nous savons que P ‚Üí Q est vrai, et nous observons que Q est vrai, donc nous concluons que P est vrai. C'est invalide.

Exemple erron√© : "Si un nombre est divisible par 4, alors il est pair. Ce nombre est pair. Donc il est divisible par 4." (Faux : 6 est pair mais pas divisible par 4.)

**N√©gation du cons√©quent valide vs n√©gation de l'ant√©c√©dent invalide** : De P ‚Üí Q et ¬¨Q, on peut d√©duire ¬¨P (c'est le modus tollens, valide). Mais de P ‚Üí Q et ¬¨P, on ne peut PAS d√©duire ¬¨Q.

Exemple erron√© : "Si il pleut, alors la rue est mouill√©e. Il ne pleut pas. Donc la rue n'est pas mouill√©e." (Faux : la rue pourrait √™tre mouill√©e pour une autre raison, comme un camion de nettoyage.)

**Raisonnement circulaire** : Utiliser la conclusion (ou quelque chose d'√©quivalent) pour prouver la conclusion.

Exemple erron√© : "Prouvons que A = B. Puisque A = B, nous avons A - B = 0, donc A = B." (Circulaire : on a suppos√© A = B pour prouver A = B.)

**G√©n√©ralisation h√¢tive** : D√©duire une propri√©t√© g√©n√©rale √† partir de cas particuliers.

Exemple erron√© : "2, 3, 5, 7, 11, 13 sont tous impairs ou √©gaux √† 2, donc tous les nombres premiers sont impairs ou √©gaux √† 2." (Correct, mais ce ne serait pas une preuve valide, juste une conjecture bas√©e sur des exemples.)

**Division par z√©ro cach√©e** : Dans les manipulations alg√©briques, diviser par une expression qui pourrait √™tre z√©ro.

**Quantificateurs mal utilis√©s** : Confondre ‚àÄx ‚àÉy P(x,y) avec ‚àÉy ‚àÄx P(x,y), ou mal g√©rer la port√©e des quantificateurs.

#### Exemple de preuve bien justifi√©e

Regardons une preuve o√π chaque √©tape est explicitement justifi√©e.

**Th√©or√®me** : Pour tous entiers positifs a et b, si a divise b et b divise a, alors a = b.

**Preuve** :

Soient a et b des entiers positifs. [Introduction des variables]

Supposons que a divise b et que b divise a. [Hypoth√®ses]

Puisque a divise b, il existe un entier k tel que b = ka. [D√©finition de "divise"] ... (1)

Puisque b divise a, il existe un entier m tel que a = mb. [D√©finition de "divise"] ... (2)

En substituant (1) dans (2), nous obtenons :
a = m(ka) [Substitution]
a = (mk)a [Associativit√© de la multiplication]

Puisque a est un entier positif, nous pouvons diviser les deux c√¥t√©s par a :
1 = mk [Division par a, valide car a > 0]

Donc mk = 1. [Sym√©trie de l'√©galit√©]

Puisque m et k sont des entiers dont le produit vaut 1, nous avons n√©cessairement m = k = 1 ou m = k = -1. [Les seuls diviseurs de 1 dans les entiers sont ¬±1]

Mais a et b sont positifs par hypoth√®se. Si m = -1, alors a = mb = -b < 0, contradiction. [Raisonnement par cas et contradiction]

Donc m = k = 1. [√âlimination de l'autre cas]

En substituant k = 1 dans l'√©quation (1), nous obtenons :
b = 1¬∑a = a [Substitution et identit√© multiplicative]

Donc a = b. ‚àé [Conclusion]

**Analyse** : Chaque assertion est justifi√©e. Les d√©finitions sont cit√©es quand on les utilise. Les manipulations alg√©briques sont explicit√©es. Le raisonnement par cas est signal√©. C'est ce niveau de pr√©cision que vous devriez viser dans vos preuves, au moins pendant votre apprentissage.

---

### üíª 6. Application √† la correction d'algorithmes

La capacit√© √† prouver des propri√©t√©s math√©matiques se transf√®re directement √† la preuve de correction d'algorithmes. Quand vous √©crivez un algorithme, vous faites implicitement une affirmation : "Si les entr√©es satisfont certaines pr√©conditions, alors cet algorithme termine et produit une sortie satisfaisant certaines postconditions." Prouver cette affirmation, c'est prouver la **correction** de l'algorithme.

#### Correction partielle vs correction totale

**Correction partielle** : Si l'algorithme termine, alors il produit le bon r√©sultat.

**Correction totale** : L'algorithme termine toujours ET produit le bon r√©sultat.

Dans cette le√ßon, nous nous concentrons sur la correction partielle. La preuve de terminaison sera vue dans des le√ßons ult√©rieures sur la r√©currence et l'induction.

#### Sp√©cification formelle : pr√©conditions et postconditions

Avant de prouver qu'un algorithme est correct, vous devez sp√©cifier formellement ce qu'il est cens√© faire. Cela se fait via :

**Pr√©conditions** : Les propri√©t√©s que les entr√©es doivent satisfaire. Par exemple, "le tableau est non vide", "n est un entier positif", "l'utilisateur existe dans la base de donn√©es".

**Postconditions** : Les propri√©t√©s que la sortie doit satisfaire si l'algorithme termine. Par exemple, "le tableau retourn√© est tri√©", "la fonction retourne true si et seulement si n est premier", "l'email a √©t√© envoy√© au destinataire".

**Notation courante** : On √©crit souvent :
```
{P} A {Q}
```
o√π P est la pr√©condition, A est l'algorithme, et Q est la postcondition. Cela signifie : "Si P est vrai avant l'ex√©cution de A, et si A termine, alors Q est vrai apr√®s l'ex√©cution de A."

#### Exemple : Fonction d'√©change de valeurs

Consid√©rons une fonction simple qui √©change les valeurs de deux variables.

**Sp√©cification** :
- Pr√©condition : Soient a et b deux variables contenant respectivement les valeurs A‚ÇÄ et B‚ÇÄ.
- Postcondition : Apr√®s l'ex√©cution, a contient B‚ÇÄ et b contient A‚ÇÄ.

**Impl√©mentation en JavaScript** :
```javascript
function swap(array, i, j) {
  // Pr√©condition : array est un tableau, 0 ‚â§ i < array.length, 0 ‚â§ j < array.length
  // Soient A‚ÇÄ = array[i] et B‚ÇÄ = array[j] avant l'ex√©cution
  
  const temp = array[i];  // temp = A‚ÇÄ
  array[i] = array[j];    // array[i] = B‚ÇÄ
  array[j] = temp;        // array[j] = A‚ÇÄ
  
  // Postcondition : array[i] = B‚ÇÄ et array[j] = A‚ÇÄ
}
```

**Preuve de correction partielle** :

Notons A‚ÇÄ la valeur initiale de array[i] et B‚ÇÄ la valeur initiale de array[j].

Apr√®s la ligne `const temp = array[i];` :
  temp = A‚ÇÄ, array[i] = A‚ÇÄ, array[j] = B‚ÇÄ

Apr√®s la ligne `array[i] = array[j];` :
  temp = A‚ÇÄ, array[i] = B‚ÇÄ, array[j] = B‚ÇÄ

Apr√®s la ligne `array[j] = temp;` :
  temp = A‚ÇÄ, array[i] = B‚ÇÄ, array[j] = A‚ÇÄ

Nous avons donc array[i] = B‚ÇÄ et array[j] = A‚ÇÄ, ce qui satisfait la postcondition.

La fonction swap est correcte (partiellement). ‚àé

**Observation** : Cette preuve suit ligne par ligne l'ex√©cution du code et montre l'√©tat des variables apr√®s chaque instruction. C'est une technique fondamentale appel√©e **analyse de trace** ou **v√©rification ligne par ligne**.

#### Exemple plus complexe : Fonction de recherche du minimum

**Sp√©cification** :
- Pr√©condition : array est un tableau non vide d'entiers.
- Postcondition : La fonction retourne l'index i tel que array[i] est le plus petit √©l√©ment du tableau.

**Impl√©mentation** :
```javascript
function findMinIndex(array) {
  // Pr√©condition : array.length > 0
  
  let minIndex = 0;  // Initialisation : on suppose que le minimum est √† l'index 0
  
  for (let i = 1; i < array.length; i++) {
    if (array[i] < array[minIndex]) {
      minIndex = i;
    }
  }
  
  // Postcondition : array[minIndex] ‚â§ array[k] pour tout k ‚àà [0, array.length-1]
  return minIndex;
}
```

**Preuve de correction partielle** :

Nous allons prouver que la postcondition est satisfaite, c'est-√†-dire que l'index retourn√© pointe vers le minimum du tableau.

**Invariant de boucle** : √Ä la fin de chaque it√©ration i de la boucle for, minIndex contient l'index du plus petit √©l√©ment parmi array[0], array[1], ..., array[i].

**V√©rification de l'invariant** :

**Initialisation** : Avant la premi√®re it√©ration (i = 1), minIndex = 0. Le plus petit √©l√©ment parmi array[0] (un seul √©l√©ment) est effectivement √† l'index 0. L'invariant est vrai. ‚úì

**Pr√©servation** : Supposons que l'invariant soit vrai au d√©but de l'it√©ration pour un certain i ‚â• 1. Cela signifie que minIndex pointe vers le minimum de array[0..i-1].

Deux cas se pr√©sentent :

**Cas 1** : array[i] < array[minIndex]. Dans ce cas, nous mettons √† jour minIndex = i. Maintenant, minIndex pointe vers array[i], qui est strictement plus petit que l'ancien minimum, donc c'est bien le minimum de array[0..i]. L'invariant est pr√©serv√©. ‚úì

**Cas 2** : array[i] ‚â• array[minIndex]. Dans ce cas, minIndex ne change pas. Le minimum de array[0..i] est le m√™me que le minimum de array[0..i-1], qui est array[minIndex]. L'invariant est pr√©serv√©. ‚úì

**Terminaison** : La boucle se termine quand i = array.length. √Ä ce moment, par l'invariant, minIndex contient l'index du minimum de array[0..array.length-1], c'est-√†-dire de tout le tableau.

Donc, la fonction retourne bien l'index du minimum du tableau. La fonction findMinIndex est correcte (partiellement). ‚àé

**Point p√©dagogique essentiel** : Cette preuve utilise une technique appel√©e **invariant de boucle**, qui est fondamentale pour prouver la correction des algorithmes it√©ratifs. Un invariant de boucle est une propri√©t√© qui reste vraie avant et apr√®s chaque it√©ration de la boucle. Nous verrons cette technique plus en d√©tail dans les le√ßons sur l'induction.

---

### üéì 7. Preuves en contexte de programmation

Maintenant que nous comprenons les principes de base des preuves directes et par contrapos√©e, voyons comment ces techniques s'appliquent √† des probl√®mes de programmation concrets.

#### Propri√©t√©s de fonctions pures

Une fonction **pure** est une fonction qui, pour les m√™mes entr√©es, produit toujours la m√™me sortie et n'a pas d'effets de bord. Les fonctions pures sont particuli√®rement agr√©ables √† raisonner car leur comportement est enti√®rement d√©termin√© par leurs entr√©es.

**Th√©or√®me** : Si f et g sont des fonctions pures, alors la composition h(x) = f(g(x)) est une fonction pure.

**Preuve directe** :

Supposons que f et g soient des fonctions pures.

Par d√©finition, g est pure signifie que pour toutes entr√©es identiques x‚ÇÅ = x‚ÇÇ, on a g(x‚ÇÅ) = g(x‚ÇÇ) et g n'a pas d'effets de bord.

De m√™me, f est pure signifie que pour toutes entr√©es identiques y‚ÇÅ = y‚ÇÇ, on a f(y‚ÇÅ) = f(y‚ÇÇ) et f n'a pas d'effets de bord.

Soit h(x) = f(g(x)).

Prenons deux entr√©es identiques x‚ÇÅ = x‚ÇÇ.

Puisque g est pure, g(x‚ÇÅ) = g(x‚ÇÇ). Notons y cette valeur commune.

Puisque f est pure, f(y) donne toujours le m√™me r√©sultat.

Donc h(x‚ÇÅ) = f(g(x‚ÇÅ)) = f(y) = f(g(x‚ÇÇ)) = h(x‚ÇÇ).

De plus, puisque ni g ni f n'ont d'effets de bord, leur composition n'en a pas non plus.

Donc h est une fonction pure. ‚àé

**Implication pratique** : Ce th√©or√®me vous garantit que composer des fonctions pures donne toujours une fonction pure. C'est un des principes fondamentaux de la programmation fonctionnelle.

#### Propri√©t√©s d'idempotence

Une op√©ration est **idempotente** si l'appliquer plusieurs fois a le m√™me effet que l'appliquer une seule fois. C'est une propri√©t√© importante dans les syst√®mes distribu√©s et les APIs.

**Th√©or√®me** : Si une fonction f satisfait f(f(x)) = f(x) pour tout x, alors f(f(f(x))) = f(x) pour tout x.

**Preuve directe** :

Soit x quelconque.

Par hypoth√®se, f(f(x)) = f(x).

Appliquons f aux deux c√¥t√©s de cette √©galit√© :
f(f(f(x))) = f(f(x))

Mais par hypoth√®se encore, f(f(x)) = f(x).

Donc f(f(f(x))) = f(x). ‚àé

**Exemple en JavaScript** :
```javascript
// Fonction idempotente : mettre en majuscules
function toUpperCase(str) {
  return str.toUpperCase();
}

// V√©rification : toUpperCase(toUpperCase("hello")) === toUpperCase("hello")
// "HELLO" === "HELLO" ‚úì

// Fonction NON idempotente : incr√©menter
function increment(n) {
  return n + 1;
}

// increment(increment(5)) = 7 ‚â† 6 = increment(5) ‚úó
```

#### Preuves avec pr√©conditions

Quand vous avez des pr√©conditions sur les entr√©es, vos preuves doivent en tenir compte.

**Th√©or√®me** : Si array est un tableau tri√© d'entiers et x < array[0], alors x n'est pas dans le tableau.

**Preuve par contrapos√©e** :

Nous allons prouver la contrapos√©e : si x est dans le tableau, alors x ‚â• array[0].

Supposons que x soit dans le tableau.

Alors il existe un index k tel que array[k] = x.

Puisque le tableau est tri√©, nous avons array[0] ‚â§ array[1] ‚â§ ... ‚â§ array[k] ‚â§ ... ‚â§ array[n-1].

En particulier, array[0] ‚â§ array[k] = x.

Donc x ‚â• array[0].

Par contrapos√©e, si x < array[0], alors x n'est pas dans le tableau. ‚àé

**Application** : Cette propri√©t√© justifie l'optimisation de sortie anticip√©e dans les algorithmes de recherche sur des tableaux tri√©s. Si vous cherchez un √©l√©ment plus petit que le premier √©l√©ment d'un tableau tri√©, vous pouvez imm√©diatement retourner "non trouv√©" sans examiner le reste du tableau.

```javascript
function binarySearchOptimized(sortedArray, target) {
  // Pr√©condition : sortedArray est tri√© en ordre croissant
  
  // Optimisation bas√©e sur notre th√©or√®me
  if (sortedArray.length === 0 || target < sortedArray[0]) {
    return -1;  // target n'est pas dans le tableau
  }
  
  // ... reste de la recherche binaire
}
```

---

## üí° Exemple travaill√© d√©taill√©

### Sc√©nario : Validation de contraintes d'int√©grit√© r√©f√©rentielle dans une base de donn√©es

Vous d√©veloppez un syst√®me de gestion d'une biblioth√®que en ligne. Votre base de donn√©es PostgreSQL contient des tables pour les livres, les emprunts, et les utilisateurs. Vous devez prouver formellement que certaines contraintes d'int√©grit√© sont respect√©es par vos fonctions de validation avant d'ins√©rer des donn√©es.

#### Contexte et sch√©ma de base de donn√©es

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    email VARCHAR(200) UNIQUE NOT NULL,
    membership_active BOOLEAN DEFAULT TRUE
);

CREATE TABLE books (
    id SERIAL PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    isbn VARCHAR(20) UNIQUE NOT NULL,
    available_copies INTEGER NOT NULL CHECK (available_copies >= 0),
    total_copies INTEGER NOT NULL CHECK (total_copies > 0)
);

CREATE TABLE loans (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) NOT NULL,
    book_id INTEGER REFERENCES books(id) NOT NULL,
    loan_date DATE NOT NULL,
    due_date DATE NOT NULL,
    return_date DATE
);
```

#### R√®gles m√©tier √† valider

**R√®gle 1** : Un utilisateur ne peut emprunter un livre que si son abonnement est actif.

**R√®gle 2** : Un livre ne peut √™tre emprunt√© que si au moins un exemplaire est disponible (available_copies > 0).

**R√®gle 3** : Si un livre a des exemplaires emprunt√©s, alors le nombre d'exemplaires disponibles doit √™tre inf√©rieur au nombre total d'exemplaires.

**R√®gle 4** : La date d'√©ch√©ance d'un emprunt doit √™tre post√©rieure √† la date d'emprunt.

#### Fonction de validation √† prouver correcte

Nous allons impl√©menter une fonction qui v√©rifie toutes ces r√®gles avant de permettre un emprunt, puis nous prouverons formellement qu'elle est correcte.

```javascript
/**
 * V√©rifie si un emprunt peut √™tre cr√©√©
 * 
 * @param {Object} user - L'utilisateur qui souhaite emprunter
 * @param {Object} book - Le livre √† emprunter
 * @param {Date} loanDate - Date de l'emprunt
 * @param {Date} dueDate - Date d'√©ch√©ance
 * @returns {Object} { valid: boolean, errors: string[] }
 */
function canCreateLoan(user, book, loanDate, dueDate) {
  const errors = [];
  
  // R√®gle 1 : V√©rifier que l'abonnement est actif
  if (!user.membershipActive) {
    errors.push('User membership is not active');
  }
  
  // R√®gle 2 : V√©rifier qu'un exemplaire est disponible
  if (book.availableCopies <= 0) {
    errors.push('No copies available for this book');
  }
  
  // R√®gle 4 : V√©rifier que due_date > loan_date
  if (dueDate <= loanDate) {
    errors.push('Due date must be after loan date');
  }
  
  return {
    valid: errors.length === 0,
    errors: errors
  };
}
```

#### Th√©or√®me 1 : Correction de la v√©rification d'abonnement

**√ânonc√©** : Si canCreateLoan retourne valid = true, alors l'utilisateur a un abonnement actif.

**Preuve directe** :

Supposons que canCreateLoan(user, book, loanDate, dueDate) retourne {valid: true, ...}.

Par d√©finition de notre fonction, valid = true si et seulement si errors.length === 0.

Donc errors.length === 0.

Examinons la ligne 12 de notre fonction :
```javascript
if (!user.membershipActive) {
  errors.push('User membership is not active');
}
```

Si user.membershipActive √©tait faux, alors la condition `!user.membershipActive` serait vraie, et nous aurions ajout√© un √©l√©ment √† errors.

Mais nous savons que errors.length === 0, donc aucun √©l√©ment n'a √©t√© ajout√© √† errors.

Donc la condition `!user.membershipActive` n'a jamais √©t√© vraie.

Donc user.membershipActive doit √™tre vrai.

Donc l'utilisateur a un abonnement actif. ‚àé

**Observation** : Cette preuve suit la structure du code. Nous avons utilis√© le fait que si un √©l√©ment avait √©t√© ajout√© au tableau errors, sa longueur ne serait pas 0. C'est un raisonnement par contrapos√©e implicite.

#### Th√©or√®me 2 : Contrapos√©e sur la disponibilit√©

**√ânonc√©** : Si un livre n'a aucun exemplaire disponible, alors canCreateLoan retourne valid = false.

**Preuve directe** :

Supposons que book.availableCopies <= 0.

Dans notre fonction, nous avons le code suivant (lignes 17-19) :
```javascript
if (book.availableCopies <= 0) {
  errors.push('No copies available for this book');
}
```

Puisque book.availableCopies <= 0, la condition est vraie.

Donc nous ex√©cutons errors.push('No copies available for this book').

Apr√®s cette ex√©cution, errors.length >= 1.

√Ä la fin de la fonction, nous retournons {valid: errors.length === 0, ...}.

Puisque errors.length >= 1, nous avons errors.length === 0 est faux.

Donc valid = false.

Donc canCreateLoan retourne valid = false. ‚àé

#### Th√©or√®me 3 : Correction de la v√©rification de dates

**√ânonc√©** : Si canCreateLoan retourne valid = true, alors dueDate > loanDate.

**Preuve par contrapos√©e** :

Nous allons prouver la contrapos√©e : si dueDate ‚â§ loanDate, alors canCreateLoan retourne valid = false.

Supposons que dueDate ‚â§ loanDate.

Dans notre fonction, nous avons le code suivant (lignes 22-24) :
```javascript
if (dueDate <= loanDate) {
  errors.push('Due date must be after loan date');
}
```

Puisque dueDate ‚â§ loanDate, la condition est vraie.

Donc nous ex√©cutons errors.push('Due date must be after loan date').

Apr√®s cette ex√©cution, errors.length >= 1.

Donc errors.length === 0 est faux.

Donc valid = false.

Donc canCreateLoan retourne valid = false.

Par contrapos√©e, si canCreateLoan retourne valid = true, alors dueDate > loanDate. ‚àé

**Pourquoi utiliser la contrapos√©e ici ?** : L'√©nonc√© original dit "si valid = true, alors dueDate > loanDate". Prouver directement √† partir de "valid = true" n√©cessiterait d'analyser toutes les fa√ßons dont valid peut √™tre true. En revanche, partir de "dueDate ‚â§ loanDate" nous donne une condition concr√®te √† analyser dans le code, rendant la preuve plus directe.

#### Th√©or√®me 4 : Compl√©tude des v√©rifications

**√ânonc√©** : Si toutes les r√®gles m√©tier sont satisfaites (membership actif, copies disponibles, dates valides), alors canCreateLoan retourne valid = true.

**Preuve directe** :

Supposons que :
- user.membershipActive = true
- book.availableCopies > 0
- dueDate > loanDate

Analysons chaque condition dans notre fonction :

**Condition 1** (ligne 12) : `!user.membershipActive`
Puisque user.membershipActive = true, nous avons !user.membershipActive = false.
La condition est fausse, donc nous n'ajoutons rien √† errors.

**Condition 2** (ligne 17) : `book.availableCopies <= 0`
Puisque book.availableCopies > 0, cette condition est fausse.
Donc nous n'ajoutons rien √† errors.

**Condition 3** (ligne 22) : `dueDate <= loanDate`
Puisque dueDate > loanDate, nous avons dueDate <= loanDate est faux.
Donc nous n'ajoutons rien √† errors.

Puisque aucun √©l√©ment n'a √©t√© ajout√© √† errors, nous avons errors.length = 0.

Donc valid = (errors.length === 0) = true.

Donc canCreateLoan retourne valid = true. ‚àé

**Signification** : Ce th√©or√®me prouve que notre fonction est **compl√®te** : si toutes les conditions sont remplies, elle accepte l'emprunt. Combin√© avec les th√©or√®mes pr√©c√©dents qui prouvent la **correction** (si elle accepte, toutes les conditions sont remplies), nous avons √©tabli que notre fonction impl√©mente exactement la sp√©cification voulue.

#### Impl√©mentation compl√®te avec la fonction de cr√©ation d'emprunt

Maintenant que nous avons prouv√© la correction de notre validation, utilisons-la dans une fonction compl√®te.

```javascript
/**
 * Cr√©e un nouvel emprunt dans le syst√®me
 * 
 * Pr√©conditions :
 *   - user existe et user.id est valide
 *   - book existe et book.id est valide
 *   - loanDate est une date valide
 *   - dueDate est une date valide
 * 
 * Postconditions (si succ√®s) :
 *   - Un nouvel emprunt est cr√©√© dans la base
 *   - book.availableCopies est d√©cr√©ment√© de 1
 *   - Retourne l'objet loan cr√©√©
 * 
 * Postconditions (si √©chec) :
 *   - Aucune modification de la base
 *   - Retourne null et un tableau d'erreurs
 */
async function createLoan(db, user, book, loanDate, dueDate) {
  // Validation
  const validation = canCreateLoan(user, book, loanDate, dueDate);
  
  if (!validation.valid) {
    return {
      success: false,
      errors: validation.errors,
      loan: null
    };
  }
  
  // √Ä ce point, par nos th√©or√®mes 1, 3, et 4 :
  // - user.membershipActive = true
  // - book.availableCopies > 0
  // - dueDate > loanDate
  
  try {
    // Commencer une transaction pour garantir l'atomicit√©
    await db.query('BEGIN');
    
    // Ins√©rer l'emprunt
    const loanResult = await db.query(
      `INSERT INTO loans (user_id, book_id, loan_date, due_date)
       VALUES ($1, $2, $3, $4)
       RETURNING *`,
      [user.id, book.id, loanDate, dueDate]
    );
    
    // D√©cr√©menter le nombre d'exemplaires disponibles
    await db.query(
      `UPDATE books
       SET available_copies = available_copies - 1
       WHERE id = $1`,
      [book.id]
    );
    
    await db.query('COMMIT');
    
    return {
      success: true,
      errors: [],
      loan: loanResult.rows[0]
    };
    
  } catch (error) {
    await db.query('ROLLBACK');
    return {
      success: false,
      errors: ['Database error: ' + error.message],
      loan: null
    };
  }
}
```

#### Th√©or√®me 5 : Invariant sur le nombre de copies

**√ânonc√©** : Si avant l'ex√©cution de createLoan nous avons book.availableCopies + book.borrowedCopies = book.totalCopies, alors apr√®s une cr√©ation r√©ussie, cette √©galit√© est pr√©serv√©e.

**Preuve directe** :

Notons :
- A‚ÇÄ = book.availableCopies avant l'ex√©cution
- B‚ÇÄ = book.borrowedCopies avant l'ex√©cution (nombre d'emprunts actifs)
- T = book.totalCopies (constant)

Par hypoth√®se, A‚ÇÄ + B‚ÇÄ = T.

Supposons que createLoan se termine avec succ√®s (success = true).

Par le Th√©or√®me 4, puisque la validation a r√©ussi, nous avons A‚ÇÄ > 0.

Dans la fonction, nous ex√©cutons (ligne 45-48) :
```javascript
UPDATE books
SET available_copies = available_copies - 1
WHERE id = book.id
```

Apr√®s cette mise √† jour, nous avons :
- A‚ÇÅ = A‚ÇÄ - 1 (available_copies d√©cr√©ment√©)
- B‚ÇÅ = B‚ÇÄ + 1 (un nouvel emprunt cr√©√©, donc borrowedCopies incr√©ment√©)

V√©rifions l'invariant :
A‚ÇÅ + B‚ÇÅ = (A‚ÇÄ - 1) + (B‚ÇÄ + 1) = A‚ÇÄ + B‚ÇÄ = T

L'√©galit√© est pr√©serv√©e. ‚àé

**Signification pratique** : Cet invariant garantit l'int√©grit√© des donn√©es. Le nombre total de copies (disponibles + emprunt√©es) reste constant. Si vous d√©tectez une violation de cet invariant dans votre base de donn√©es, vous savez qu'une erreur s'est produite quelque part dans votre syst√®me.

#### V√©rification en SQL avec contraintes et triggers

Nous pouvons impl√©menter ces v√©rifications directement en SQL pour avoir une double validation (application + base de donn√©es).

```sql
-- Trigger pour v√©rifier la disponibilit√© avant insertion d'un emprunt
CREATE OR REPLACE FUNCTION check_book_availability()
RETURNS TRIGGER AS $$
DECLARE
    available INTEGER;
BEGIN
    -- V√©rifier le nombre de copies disponibles
    SELECT available_copies INTO available
    FROM books
    WHERE id = NEW.book_id;
    
    -- R√®gle 2 : Au moins une copie disponible
    IF available <= 0 THEN
        RAISE EXCEPTION 'No copies available for book ID %', NEW.book_id;
    END IF;
    
    -- R√®gle 4 : due_date > loan_date
    IF NEW.due_date <= NEW.loan_date THEN
        RAISE EXCEPTION 'Due date must be after loan date';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_loan_insert
BEFORE INSERT ON loans
FOR EACH ROW
EXECUTE FUNCTION check_book_availability();

-- Contrainte CHECK pour garantir la coh√©rence des copies
ALTER TABLE books
ADD CONSTRAINT check_copies_consistency
CHECK (available_copies <= total_copies);

-- Contrainte pour garantir les valeurs positives
ALTER TABLE books
ADD CONSTRAINT check_positive_copies
CHECK (available_copies >= 0 AND total_copies > 0);
```

**Th√©or√®me 6** : Avec ces contraintes SQL, il est impossible d'ins√©rer un emprunt qui violerait les r√®gles m√©tier.

**Preuve** : Cette preuve repose sur les garanties fournies par PostgreSQL.

Par les contraintes CHECK d√©finies, PostgreSQL refuse toute op√©ration qui violerait available_copies >= 0 ou total_copies > 0.

Par le trigger before_loan_insert, toute tentative d'insertion dans loans d√©clenche check_book_availability().

Cette fonction v√©rifie available_copies > 0 et due_date > loan_date.

Si l'une de ces conditions n'est pas satisfaite, une exception est lev√©e et l'insertion est annul√©e.

Si l'une de ces conditions n'est pas satisfaite, une exception est lev√©e et l'insertion est annul√©e.

Donc, par les m√©canismes de PostgreSQL, aucun emprunt violant les r√®gles ne peut √™tre ins√©r√©. ‚àé

Cette preuve repose sur les propri√©t√©s de PostgreSQL (execution atomique des triggers, v√©rification des contraintes avant commit), qui sont elles-m√™mes prouv√©es correctes dans l'impl√©mentation du SGBD.

---

## üéØ Exercices appliqu√©s

### Exercice 1 : Niveau Facile - Preuve directe sur les nombres

**√ânonc√©** : Prouvez les th√©or√®mes suivants en utilisant une preuve directe. Pour chaque preuve, identifiez clairement les hypoth√®ses, justifiez chaque √©tape, et √©noncez explicitement la conclusion.

**a)** Pour tout entier n, si n est divisible par 6, alors n est divisible par 3.

**b)** Pour tous entiers a et b, si a est pair et b est pair, alors a + b est pair.

**c)** Pour tout entier n, si n¬≤ est divisible par 4, alors n est pair.

**Crit√®res d'√©valuation** :
- √ânonc√© clair des hypoth√®ses (1 point par preuve)
- Utilisation correcte des d√©finitions (1 point par preuve)
- Cha√Æne d'implications valides (2 points par preuve)
- Conclusion explicite (1 point par preuve)

**Indice** : Pour chaque preuve, commencez par √©crire la d√©finition formelle des termes utilis√©s. Par exemple, "n est divisible par 6" signifie "il existe un entier k tel que n = 6k". D√©veloppez les hypoth√®ses en utilisant ces d√©finitions, puis manipulez alg√©briquement pour arriver √† la conclusion.

**Solution compl√®te** :

**Preuve de (a)** :

Soit n un entier quelconque.

Supposons que n soit divisible par 6.

Par d√©finition, cela signifie qu'il existe un entier k tel que n = 6k.

Nous pouvons r√©√©crire cette expression :
n = 6k = 3(2k)

Posons m = 2k. Puisque k est un entier, m = 2k est √©galement un entier.

Nous avons donc n = 3m o√π m est un entier.

Par d√©finition, cela signifie que n est divisible par 3.

Conclusion : Si n est divisible par 6, alors n est divisible par 3. ‚àé

---

**Preuve de (b)** :

Soient a et b des entiers quelconques.

Supposons que a soit pair et que b soit pair.

Par d√©finition de nombre pair, il existe des entiers k et m tels que :
- a = 2k
- b = 2m

Calculons a + b :
a + b = 2k + 2m
      = 2(k + m)

Posons p = k + m. Puisque k et m sont des entiers, p = k + m est √©galement un entier.

Nous avons donc a + b = 2p o√π p est un entier.

Par d√©finition, cela signifie que a + b est pair.

Conclusion : Si a est pair et b est pair, alors a + b est pair. ‚àé

---

**Preuve de (c)** :

Soit n un entier quelconque.

Supposons que n¬≤ soit divisible par 4.

Par d√©finition, il existe un entier k tel que n¬≤ = 4k.

Nous savons que 4k = 4k est pair (car 4k = 2(2k)).

Donc n¬≤ est pair.

Or, nous avons vu dans le cours (le√ßon sur la contrapos√©e) que si n¬≤ est pair, alors n est pair.

[Rappel de la preuve : si n √©tait impair, alors n = 2m+1 pour un certain entier m, et n¬≤ = (2m+1)¬≤ = 4m¬≤ + 4m + 1 = 2(2m¬≤ + 2m) + 1, donc n¬≤ serait impair, contradiction.]

Donc n est pair.

Conclusion : Si n¬≤ est divisible par 4, alors n est pair. ‚àé

**Note p√©dagogique** : Cette derni√®re preuve utilise un r√©sultat pr√©c√©dent (si n¬≤ est pair, alors n est pair). Dans une preuve rigoureuse, vous devriez soit prouver ce r√©sultat au pr√©alable, soit le rappeler avec sa preuve, soit le citer comme "th√©or√®me pr√©c√©dent" ou "lemme auxiliaire".

---

### Exercice 2 : Niveau Moyen - Preuve par contrapos√©e

**√ânonc√©** : Pour chacun des √©nonc√©s suivants, d√©terminez si une preuve directe ou par contrapos√©e serait plus appropri√©e. Justifiez votre choix en une phrase, puis construisez la preuve.

**a)** Pour tous entiers a et b, si ab est impair, alors a est impair et b est impair.

**b)** Pour tout entier n ‚â• 2, si n n'a pas de diviseur premier inf√©rieur ou √©gal √† ‚àön, alors n est premier.

**c)** Pour toute fonction f : ‚Ñù ‚Üí ‚Ñù, si f n'est pas continue, alors il existe un point x‚ÇÄ o√π f n'est pas continue.

**Crit√®res d'√©valuation** :
- Choix justifi√© de la m√©thode (1 point par √©nonc√©)
- Structure de preuve correcte (2 points par √©nonc√©)
- Rigueur et compl√©tude des arguments (2 points par √©nonc√©)

**Indice** : Examinez la structure de chaque √©nonc√©. La conclusion est-elle une n√©gation ou une conjonction/disjonction ? L'hypoth√®se est-elle plus facile √† d√©velopper que sa n√©gation ? Pour (a), pensez √† la contrapos√©e. Pour (b), r√©fl√©chissez √† ce que signifie "n n'est pas premier". Pour (c), c'est presque une tautologie si vous comprenez bien les quantificateurs.

**Solution partielle pour vous guider** :

**Analyse de (a)** :

**Choix** : Contrapos√©e recommand√©e.

**Justification** : La conclusion est une conjonction "a est impair ET b est impair". En contrapos√©e, cela devient une disjonction "a est pair OU b est pair", qui se d√©veloppe plus facilement. De plus, travailler avec "a est pair" (d√©finition positive : a = 2k) est plus maniable que "a est impair" dans ce contexte.

**Preuve par contrapos√©e** :

Nous allons prouver la contrapos√©e : si a est pair ou b est pair, alors ab est pair.

Soient a et b des entiers quelconques.

Supposons que a soit pair ou b soit pair.

**Cas 1** : Supposons que a soit pair.
Alors il existe un entier k tel que a = 2k.
Donc ab = (2k)b = 2(kb).
Posons m = kb. Puisque k et b sont des entiers, m est un entier.
Donc ab = 2m, ce qui signifie que ab est pair.

**Cas 2** : Supposons que b soit pair.
Par un raisonnement sym√©trique au Cas 1, ab est pair.

Dans les deux cas, ab est pair.

Par contrapos√©e, si ab est impair, alors a est impair et b est impair. ‚àé

---

**√Ä vous de faire (b) et (c)** : Analysez la structure de ces √©nonc√©s et construisez les preuves. Pour (b), la contrapos√©e sera plus naturelle (pensez √† ce que signifie "n n'est pas premier"). Pour (c), r√©fl√©chissez bien √† la logique des quantificateurs : l'√©nonc√© est presque une reformulation de la d√©finition de "f n'est pas continue".

---

### Exercice 3 : Niveau Difficile - Preuve de correction d'algorithme

**√ânonc√©** : Vous impl√©mentez une fonction qui v√©rifie si une cha√Æne de caract√®res est un palindrome (se lit de la m√™me mani√®re dans les deux sens). √âcrivez une sp√©cification formelle de cette fonction, impl√©mentez-la en JavaScript, puis prouvez sa correction partielle.

**Sp√©cification √† compl√©ter** :

**Pr√©conditions** :
- str est une cha√Æne de caract√®res non vide
- str ne contient que des lettres minuscules (a-z)

**Postconditions** :
- La fonction retourne true si et seulement si str[i] = str[n-1-i] pour tout i ‚àà [0, n-1], o√π n est la longueur de str

**T√¢ches** :

1. Impl√©mentez la fonction `isPalindrome(str)` en JavaScript avec deux approches diff√©rentes :
   - **Approche it√©rative** : Utiliser deux pointeurs (d√©but et fin) qui se rapprochent
   - **Approche r√©cursive** : Fonction r√©cursive qui compare premier et dernier caract√®re

2. Pour chaque impl√©mentation, prouvez formellement sa correction partielle en :
   - √âtablissant un invariant de boucle (pour l'approche it√©rative)
   - Utilisant l'induction forte (pour l'approche r√©cursive)

3. Prouvez que les deux impl√©mentations sont √©quivalentes (retournent le m√™me r√©sultat pour toute entr√©e valide)

4. Identifiez et corrigez une version bugg√©e de la fonction qui est fournie ci-dessous :

```javascript
// Version avec bug - trouvez et corrigez l'erreur
function isPalindromeBuggy(str) {
  for (let i = 0; i < str.length; i++) {
    if (str[i] !== str[str.length - i]) {
      return false;
    }
  }
  return true;
}
```

5. √âtendez votre preuve pour g√©rer des cha√Ænes avec des espaces et des majuscules (en les ignorant). Adaptez la sp√©cification et la preuve en cons√©quence.

**Crit√®res d'√©valuation** :
- Sp√©cification formelle claire et compl√®te (2 points)
- Impl√©mentations correctes et bien comment√©es (2 points)
- Preuve de correction pour l'approche it√©rative avec invariant (3 points)
- Preuve de correction pour l'approche r√©cursive (2 points)
- Preuve d'√©quivalence entre les deux approches (2 points)
- Identification et correction du bug avec explication (1 point)
- Extension correcte pour les espaces et majuscules (1 point)

**Indice** : Pour l'invariant de boucle dans l'approche it√©rative, pensez √† une propri√©t√© qui affirme que "jusqu'√† pr√©sent, les caract√®res v√©rifi√©s sont sym√©triques". Pour le bug, examinez attentivement l'indexation : que vaut `str[str.length - i]` quand i = 0 ? Pour l'extension, vous aurez besoin de preprocesser la cha√Æne d'abord, ce qui n√©cessite d'adapter votre sp√©cification pour distinguer la cha√Æne originale de la cha√Æne normalis√©e.

**Note** : Cet exercice est cons√©quent et constitue un mini-projet. Il n'y a pas de solution fournie pour vous permettre de le d√©velopper en autonomie. C'est une excellente opportunit√© de mettre en pratique toutes les techniques de preuve vues dans cette le√ßon. Si vous √™tes bloqu√©, relisez la section sur les invariants de boucle dans l'exemple travaill√© (fonction findMinIndex).

---

## üìö Ressources recommand√©es

### Ressource 1 (Priorit√© maximale) : Livre de r√©f√©rence - M√©thodes de preuve

**Type** : Livre acad√©mique  
**Titre** : "How to Prove It: A Structured Approach" (3e √©dition)  
**Auteur** : Daniel J. Velleman  
**√âditeur** : Cambridge University Press  
**Sections pertinentes** : Chapitres 1-3 (Sentential Logic, Quantificational Logic, Proofs)

**Pourquoi cette ressource est recommand√©e** : Ce livre est consid√©r√© comme la meilleure introduction aux techniques de preuve math√©matique. Velleman adopte une approche p√©dagogique progressive qui vous enseigne non seulement quelles techniques utiliser, mais surtout comment penser lors de la construction d'une preuve. Chaque chapitre contient de nombreux exercices corrig√©s qui renforcent les concepts. Le style est accessible sans sacrifier la rigueur. C'est la ressource parfaite pour compl√©ter cette le√ßon et d√©velopper votre intuition pour les preuves.

---

### Ressource 2 (Priorit√© maximale) : Cours MIT avec vid√©os

**Type** : Cours en ligne avec vid√©os et notes  
**Titre** : MIT 6.042J Mathematics for Computer Science - Lectures 1-5  
**Professeurs** : Albert Meyer et Adam Chlipala  
**Disponibilit√©** : Gratuit sur MIT OpenCourseWare

**Pourquoi cette ressource est recommand√©e** : Les premi√®res lectures de ce cours MIT couvrent exactement les techniques de preuve que nous avons vues dans cette le√ßon. Les professeurs pr√©sentent de nombreux exemples de preuves bien construites et mal construites, ce qui vous aide √† d√©velopper votre sens critique. Les vid√©os incluent des sessions interactives o√π des √©tudiants posent des questions, ce qui peut r√©pondre √† vos propres interrogations. Les notes de cours sont exceptionnellement bien r√©dig√©es et peuvent servir de r√©f√©rence rapide.

---

### Ressource 3 (Priorit√© haute) : Tutoriel interactif sur la logique

**Type** : Cours interactif en ligne  
**Titre** : "Introduction to Mathematical Thinking" - Coursera  
**Professeur** : Keith Devlin (Stanford University)  
**Plateforme** : Coursera

**Pourquoi cette ressource est recommand√©e** : Keith Devlin est un excellent p√©dagogue qui comprend les difficult√©s que rencontrent les √©tudiants lors de leur premi√®re exposition aux preuves math√©matiques formelles. Son cours inclut des quiz interactifs qui vous permettent de pratiquer la construction de preuves avec feedback imm√©diat. Les semaines 2 et 3 du cours se concentrent sp√©cifiquement sur les preuves directes et par contrapos√©e. L'approche est tr√®s pratique avec de nombreux exemples travaill√©s.

---

### Ressource 4 (Priorit√© moyenne-haute) : Livre sur les preuves en informatique

**Type** : Livre  
**Titre** : "Mathematical Reasoning: Writing and Proof" (Version 3)  
**Auteur** : Ted Sundstrom  
**Disponibilit√©** : Gratuit en ligne (open textbook)  
**URL** : Disponible sur le site de l'auteur

**Pourquoi cette ressource est recommand√©e** : Ce livre open-source est sp√©cialement con√ßu pour les √©tudiants en informatique et math√©matiques. Il adopte une approche tr√®s progressive avec beaucoup d'exemples et d'exercices. Ce qui le distingue est son focus sur le "processus" de construction de preuve plut√¥t que seulement le produit final. Le Chapitre 3 (Constructing and Writing Proofs) est particuli√®rement pertinent pour cette le√ßon. Le fait qu'il soit gratuit en fait une ressource accessible √† tous.

---

### Ressource 5 (Priorit√© moyenne) : Outil de v√©rification formelle

**Type** : Logiciel / Outil en ligne  
**Titre** : "Coq Proof Assistant" ou "Lean Proof Assistant"  
**Disponibilit√©** : Gratuit, open source

**Pourquoi cette ressource est recommand√©e** : Ces assistants de preuve vous permettent de construire des preuves formelles que l'ordinateur v√©rifie automatiquement. Bien que leur utilisation soit avanc√©e, m√™me une exploration superficielle vous donnera une appr√©ciation profonde de ce que signifie "rigueur formelle". De nombreux tutoriels en ligne existent pour d√©buter avec ces outils. Ils sont particuli√®rement utiles si vous souhaitez prouver formellement la correction de vos algorithmes. R√©serv√© aux √©tudiants motiv√©s qui veulent aller au-del√† du curriculum standard.

---

### Ressource 6 (Priorit√© moyenne) : Articles acad√©miques appliqu√©s

**Type** : Collection d'articles  
**Titre** : "Program Verification Using Hoare Logic"  
**Contexte** : Articles et tutoriels sur la logique de Hoare  
**Disponibilit√©** : Divers articles acad√©miques sur Google Scholar ou arXiv

**Pourquoi cette ressource est recommand√©e** : La logique de Hoare est un syst√®me formel pour prouver la correction de programmes. M√™me si nous n'avons pas couvert ce syst√®me en d√©tail dans cette le√ßon, les articles d'introduction sur ce sujet montrent des applications concr√®tes des techniques de preuve √† la v√©rification de programmes. Cela renforce la connexion entre preuves math√©matiques abstraites et correction de code. Recherchez en particulier les tutoriels d'introduction qui pr√©sentent des preuves de correction pour des algorithmes simples comme le tri.

---

## üìä Grille d'√©valuation

### Crit√®re 1 : Compr√©hension de la structure d'une preuve (4 points)

**4 points** : Capacit√© √† identifier clairement toutes les composantes d'une preuve (hypoth√®ses, d√©veloppement, conclusion), √† distinguer une preuve valide d'un argument informel, et √† expliquer le r√¥le de chaque partie.

**3 points** : Bonne compr√©hension g√©n√©rale mais avec des confusions occasionnelles sur ce qui constitue une justification valide vs une affirmation qui n√©cessite justification.

**2 points** : Compr√©hension de base de la structure, mais difficult√© √† maintenir la rigueur tout au long d'une preuve.

**1 point** : Confusion entre preuve et v√©rification d'exemples, ou incapacit√© √† structurer une preuve formelle.

**0 point** : Incompr√©hension de ce qu'est une preuve math√©matique.

---

### Crit√®re 2 : Construction de preuves directes (5 points)

**5 points** : Capacit√© √† construire des preuves directes correctes et compl√®tes, avec chaque √©tape justifi√©e par une d√©finition, axiome, ou th√©or√®me appropri√©. Les manipulations alg√©briques sont explicites et correctes.

**4 points** : Preuves g√©n√©ralement correctes mais avec des √©tapes occasionnellement non justifi√©es, ou des sauts logiques mineurs qui ne compromettent pas la validit√© globale.

**3 points** : Structure de base correcte (hypoth√®se ‚Üí d√©veloppement ‚Üí conclusion), mais avec des lacunes dans les justifications ou des √©tapes manquantes dans la cha√Æne de raisonnement.

**2 points** : Tentative de preuve directe avec l'id√©e g√©n√©rale correcte, mais erreurs significatives dans les manipulations ou justifications insuffisantes.

**1 point** : Preuve incompl√®te ou contenant des erreurs logiques majeures.

**0 point** : Incapacit√© √† construire une preuve directe m√™me simple.

---

### Crit√®re 3 : Ma√Ætrise de la contrapos√©e (4 points)

**4 points** : Reconnaissance correcte des situations o√π la contrapos√©e est avantageuse, construction correcte de la contrapos√©e (¬¨Q ‚Üí ¬¨P), et preuve compl√®te et valide.

**3 points** : Capacit√© √† construire la contrapos√©e correctement mais choix sous-optimal entre preuve directe et contrapos√©e dans certains cas.

**2 points** : Compr√©hension du principe de la contrapos√©e mais erreurs dans la n√©gation des √©nonc√©s complexes ou dans la construction de la preuve.

**1 point** : Confusion fr√©quente entre contrapos√©e, r√©ciproque, et inverse, ou application incorrecte de la contrapos√©e.

**0 point** : Incompr√©hension de la technique de contrapos√©e.

---

### Crit√®re 4 : Justification et rigueur (3 points)

**3 points** : Chaque √©tape d'une preuve est explicitement justifi√©e avec r√©f√©rence appropri√©e (d√©finition, axiome, th√©or√®me). Utilisation correcte de la terminologie math√©matique ("par d√©finition", "d'apr√®s le th√©or√®me", etc.).

**2 points** : Justifications g√©n√©ralement pr√©sentes mais parfois vagues ou incompl√®tes ("c'est √©vident", "clairement").

**1 point** : Justifications rares ou inad√©quates, beaucoup de sauts logiques non justifi√©s.

**0 point** : Absence de justifications, affirmations sans support.

---

### Crit√®re 5 : D√©tection d'erreurs logiques (2 points)

**2 points** : Capacit√© √† identifier les erreurs de raisonnement courantes (affirmation du cons√©quent, raisonnement circulaire, etc.) dans des preuves incorrectes, et √† expliquer pourquoi elles sont invalides.

**1 point** : D√©tection de certaines erreurs √©videntes mais difficult√© avec les erreurs plus subtiles.

**0 point** : Incapacit√© √† distinguer les raisonnements valides des invalides.

---

### Crit√®re 6 : Application √† la correction d'algorithmes (4 points)

**4 points** : Capacit√© √† sp√©cifier formellement des pr√©conditions et postconditions, √† construire des preuves de correction partielle avec invariants de boucle corrects, et √† relier les preuves au code de mani√®re pr√©cise.

**3 points** : Preuves de correction g√©n√©ralement correctes mais avec des invariants incomplets ou des cas non couverts.

**2 points** : Compr√©hension du principe mais difficult√© √† formaliser ou √† maintenir la correspondance entre code et preuve.

**1 point** : Tentative de preuve de correction mais avec des erreurs majeures ou confusion entre correction partielle et totale.

**0 point** : Incapacit√© √† appliquer les techniques de preuve au code.

---

### Bar√®me de notation global

**20-22 points** : Excellent. Ma√Ætrise compl√®te des techniques de preuve directe et par contrapos√©e, avec capacit√© √† les appliquer √† la v√©rification de programmes.

**17-19 points** : Tr√®s bien. Bonne ma√Ætrise avec quelques imperfections mineures dans la rigueur ou les justifications.

**14-16 points** : Bien. Compr√©hension solide des concepts avec capacit√© √† construire des preuves simples, mais difficult√© avec les cas plus complexes.

**11-13 points** : Passable. Compr√©hension de base suffisante mais n√©cessite plus de pratique pour construire des preuves compl√®tes et rigoureuses.

**< 11 points** : Insuffisant. R√©vision n√©cessaire avant de progresser vers des techniques de preuve plus avanc√©es (induction, r√©currence).

---

## üéì Conclusion de la le√ßon

F√©licitations pour avoir compl√©t√© cette le√ßon fondamentale sur les techniques de preuve ! Vous avez franchi un cap important dans votre d√©veloppement en tant qu'informaticien th√©orique. La capacit√© √† construire des preuves rigoureuses n'est pas seulement une comp√©tence acad√©mique abstraite. C'est un outil puissant qui vous permet de raisonner avec certitude sur vos algorithmes et syst√®mes, plut√¥t que de vous fier uniquement √† des tests ou √† l'intuition.

**Concepts cl√©s √† retenir** :

Une preuve math√©matique est une cha√Æne d'implications logiques qui part des hypoth√®ses et arrive √† la conclusion en utilisant uniquement des d√©finitions, axiomes, th√©or√®mes pr√©c√©dents, et r√®gles d'inf√©rence valides. Chaque √©tape doit √™tre justifiable et la preuve doit √™tre en principe v√©rifiable par n'importe qui ayant les connaissances math√©matiques appropri√©es.

La preuve directe est votre outil de premier choix. Elle suit le flux naturel de la pens√©e : partez de ce que vous savez (les hypoth√®ses), d√©veloppez-les en utilisant des d√©finitions et des propri√©t√©s connues, et progressez jusqu'√† √©tablir ce que vous voulez montrer (la conclusion). La cl√© est de maintenir une rigueur constante : justifiez chaque √©tape, m√™me celles qui vous semblent √©videntes.

La preuve par contrapos√©e est une alternative puissante quand la preuve directe devient trop complexe. Rappelez-vous que P ‚Üí Q est logiquement √©quivalent √† ¬¨Q ‚Üí ¬¨P. Quand la conclusion Q est une n√©gation ou quand l'hypoth√®se P est difficile √† d√©velopper directement, essayez la contrapos√©e. Souvent, partir de ¬¨Q vous donne une hypoth√®se concr√®te et maniable pour commencer votre raisonnement.

La justification explicite de chaque √©tape est ce qui transforme une intuition informelle en preuve formelle. Prenez l'habitude de citer les d√©finitions que vous utilisez, les th√©or√®mes sur lesquels vous vous appuyez, les propri√©t√©s alg√©briques que vous appliquez. Cette discipline d√©veloppera votre rigueur et √©vitera les erreurs subtiles.

L'application √† la correction d'algorithmes montre la pertinence pratique de ces techniques. Prouver qu'un algorithme fait ce qu'il pr√©tend faire n√©cessite exactement les m√™mes comp√©tences que prouver un th√©or√®me math√©matique. Les pr√©conditions sont vos hypoth√®ses, les postconditions sont votre conclusion, et le code est votre d√©monstration que l'une implique l'autre.

**Erreurs courantes √† √©viter** : Ne confondez jamais v√©rification d'exemples et preuve g√©n√©rale. Ne tombez pas dans le pi√®ge de l'affirmation du cons√©quent. N'utilisez pas de raisonnement circulaire. Ne faites pas de sauts logiques injustifi√©s. Quand vous r√©digez une preuve, demandez-vous apr√®s chaque phrase : "Est-ce que cette assertion d√©coule logiquement de ce qui pr√©c√®de ? Quelle justification puis-je donner ?"

**Prochaines √©tapes** : La le√ßon suivante (M1.C1.L4 - Preuve par contradiction et par r√©currence) vous enseignera deux autres techniques de preuve essentielles. La preuve par contradiction est particuli√®rement utile pour les √©nonc√©s existentiels et les propri√©t√©s d'unicit√©. La r√©currence (induction math√©matique) est la technique par excellence pour prouver des propri√©t√©s sur des structures d√©finies r√©cursivement (entiers naturels, listes, arbres) et pour √©tablir la correction d'algorithmes r√©cursifs et it√©ratifs. Ces techniques, combin√©es √† celles que vous avez apprises aujourd'hui, formeront votre arsenal complet de m√©thodes de preuve.

**Conseil pratique pour progresser** : La ma√Ætrise des preuves vient avec la pratique d√©lib√©r√©e. Ne vous contentez pas de lire des preuves. √âcrivez-en. Commencez par des th√©or√®mes simples et augmentez progressivement la difficult√©. Quand vous lisez une preuve dans un livre ou un article, couvrez-la et essayez de la reconstruire vous-m√™me avant de v√©rifier. Quand vous √©crivez du code, prenez l'habitude d'√©noncer mentalement (ou par √©crit pour les fonctions importantes) les pr√©conditions et postconditions, et de vous demander "Pourquoi cette fonction est-elle correcte ?". Cette discipline transformera profond√©ment votre approche du d√©veloppement logiciel.

Rappelez-vous que m√™me les math√©maticiens et informaticiens exp√©riment√©s trouvent certaines preuves difficiles. La difficult√© ne signifie pas que vous n'√™tes pas fait pour cela. Elle signifie que vous √™tes en train de d√©velopper une comp√©tence sophistiqu√©e qui demande du temps et de l'effort. Pers√©v√©rez, et vous d√©velopperez progressivement l'intuition qui rend les preuves plus naturelles.

---

**Derni√®re mise √† jour** : Janvier 2026  
**Auteur** : Curriculum Computer Science - Version 1.0